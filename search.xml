<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[assign VS weak? __weak VS __block?]]></title>
    <url>%2F2019%2F06%2F11%2Fassign-VS-weak-block-VS-weak%2F</url>
    <content type="text"><![CDATA[零碎却不简单。 assignassign 用于基础类型的赋值，不改变属性的引用计数。如：NSInteger, CGFloat, int float double assign其实也可以用来修饰对象，但是你可不要轻易尝试。因为被assign修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil。如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。 weakweak 用于对象类型，不改变属性的引用计数，当该对象被释放的时候，该弱引用的属性自动失效并且被赋值为nil，该属性可以避免循环引用问题。 __weak__weak是所有权修饰符，被修饰的变量在使用结束后会被释放。(不会在block代码块中被retain)所有权修饰符包括: __strong, __weak, __unsafe_unretained, __autorealease。 使用__unsafe_unretained 和 __weak都可以避免循环引用的问题，但由于前者是unsafe的，会造成野指针问题，所以尽量少用unsafe_unretained关键字 __block__block用于指明当前变量可以在block内部进行修改（ARC下会被retain）。 因为在block申明的同时会捕获该block所使用的全部自动变量的值，仅有使用权没有修改权利，使用了__block关键字修饰后的变量可以在block内部进行修改。 在block内，要避免循环引用要使用： 1__weak__typeof(self)weakSelf =self; 并且，在使用到self之后的对象或者属性防止在使用之前被析构引发不可预测的问题，所以要使用strong再把它持有一下。 1__strong__typeof(weakSelf)strongSelf = weakSelf; 易混淆点若 object 本身沒有去 retain 这个 block (即block不是某个对象的property)，則可以直接在 block 中使用 self。比如自定义的block块（一个匿名函数）在代码中执行；经常问到的animation动画是否需要使用weakblock的问题。 事实上大多數的 iOS 原生套件，以及 GCD 的 block 是不會造成 retain cycle 的，因为他们并沒有去 retain block。 特别要注意的是，讲一个变量直接定义为实例变量而非属性的时候，在block中使用时还是会retain到self导致循环引用，因为ivar也是self的一部分： 1234567@interface XXXViewController () &#123; NSString *str;&#125;self.completionHandler = ^&#123; // 直接引用就相当于 self-&gt;str NSLog(@"%@", str);&#125; 但是！ivar是无法用weakSelf去取值的，因此这里正确的做法还是要用到weakSelf和strongSelf的帮助： 12345__weak __typeof(self) weakSelf = self;self.completionHandler = ^&#123; __strong __typeof(weakSelf) strongSelf = weakSelf; NSLog(@"%@", strongSelf-&gt;str);&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS内存管理原理浅谈]]></title>
    <url>%2F2019%2F05%2F30%2FiOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[iOS的内存管理策略是什么？ ARC又是为了什么而诞生的？ 来自面试官的拷问 2011 年，苹果在 WWDC 大会上提出了自动的引用计数（ARC）。ARC 背后的原理是依赖编译器的静态分析能力，通过在编译时找出合理的位置，自动插入引用计数管理代码，从而彻底解放被内存管理禁锢的码农iOS开发者。 引用计数原理引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。 当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象是，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。 解决的问题在没有引用计数的情况下，一般内存管理的原则是 “谁申请谁释放”，但是当多个对象需要引用到某一个X对象/变量时，哪些对象需要长时间使用X对象，都会遇到谁来销毁X对象的问题。引用计数的出现，使得对象在被创建和使用时retain count +1，使用完后-1，对象的生命周期就可以交给引用计数来记录。 不要向已经释放的对象发送消息当某个对象的内存已经被回收，但是我们没有对他置空(nil)，仍然向它发送消息时，如果该内存被复用了，很可能会造成程序异常崩溃，也被称为僵尸对象或者野指针异常。 ARCARC 能解决 iOS 开发中 “极大部分” 的内存管理问题，但是开发者仍然需要注意： iOS 底层的 ** Core Foundation 对象 ** 不在 ARC 的管理下，需要手工管理它们的引用计数。 避免循环引用问题。 block及delegate的内存管理。 循环引用引用计数这种管理内存的方式有一个比较大的瑕疵，即不能很好的解决循环引用（Reference Cycle）问题。 对象 A 和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。这两个对象的销毁依赖于对方的销毁，即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。 多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，这种情况更难被发现。 主动断开如果程序员明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。例如如下一个引用链： Controller 持有了网络请求对象 网络请求对象持有了回调的 block 回调的 block 里面使用了 self（即持有了 Controller） 解决办法就是，在网络请求结束，网络请求对象执行完 block 之后，主动释放对于 block 的持有，以便打破循环引用。（xxx.Block = nil） 弱引用弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。 在 iOS 开发中，弱引用通常在 delegate 模式中使用，View Controller 的 delegate 成员变量通常是一个弱引用，以避免两个 ViewController 造成循环引用问题，例如tableView的delegate。 弱引用的实现原理系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。 从原理我们得知，弱引用的使用是有额外开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用，因为： 当我们在创建这个对象时，如果临时使用一个弱引用持有它，就会因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。 大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。 Xcode 检测循环引用在 Xcode 的菜单栏选择：Product -&gt; Profile，然后选择 “Leaks”，再点击右下角的”Profile” 按钮开始检测。 我们在模拟器里进行一些界面的切换。如果出现了内存泄漏，就可以在 Instruments 中看到红色的带”x”的图标写着“n new leaks”.. 点击 “Leaks Checks” 栏，再点击”Cycles &amp; Roots”，就可以看到以图形方式显示出来的循环引用。可以比较方便地找到循环引用的对象了。如图：]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“git add .” not worked - “诡异”问题解决]]></title>
    <url>%2F2019%2F05%2F26%2F%E2%80%9Cgit-add-%E2%80%9D-not-worked-%E2%80%9C%E8%AF%A1%E5%BC%82%E2%80%9D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[听终端的话，别留下warning。 1234567891011$ git add .$ git commit -m "fuckit"On branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) (commit or discard the untracked or modified content in submodules) modified: xxx/themes/next (modified content, untracked content)no changes added to commit (use "git add" and/or "git commit -a") 起因自从把博客源码托管到github仓库之后，腰也不酸了，腿也不痛了，一口气上五楼..咳咳 之后我给hexo换了一个NEXT主题，爽炸了！可是今天修改了主题某个js文件，“git status”之后却显示“nothing to commit” ??? 上github上看源码仓库，却发现主题文件夹下空空如也..仓库却显示没问题，git log，一直停留在上个提交版本。 于是一直死循环操作“git add .”&amp;&amp;“git commit -m “xxx””，终端却一直无情回复我“Changes not staged for commit”，如上面那段代码所示。 尝试按照终端提示的办法无法解决。 这就很诡异了？于是我花了一个晚上疯狂踩坑.. 爬坑搜索了各个关键词句，看了stackoverflow和几篇无用博文还是没有找到合适的解决。直觉是文件引入的问题，一口气把next文件 “git rm –f xxx/themes/next” 再add进去，仔细一看却发现有如下提示： 123456789101112131415$ git add .warning: adding embedded git repository: xxx/themes/nexthint: You've added another git repository inside your current repository.hint: Clones of the outer repository will not contain the contents ofhint: the embedded repository and will not know how to obtain it.hint: If you meant to add a submodule, use:hint:hint: git submodule add &lt;url&gt; xxx/themes/nexthint:hint: If you added this path by mistake, you can remove it from thehint: index with:hint:hint: git rm --cached xxx/themes/nexthint:hint: See "git help submodule" for more information. 还好我认识一点英文，想起当时是从git仓库直接克隆next的，却因为粗心没有看warning，径直commit了（居然也没事- -!），才会引发以上的惨剧。于是乎赶紧把主题下的git仓库删除了。 偷了个懒，把next文件夹移走，commit，再移进来，add之后总算能看到一排排的主题相关文件辣～ 总结git仓库下要提交A文件夹，A/B文件夹下也包含一个git仓库（.git）。使用git add . 就只能加入一个空的B文件夹。 这个故事告诉我们以LINUX“没有回应就是最好的回应”的尿性来说，还是好好看终端回复吧。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
