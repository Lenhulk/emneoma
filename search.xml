<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一文解决scrollView中恼人的手势冲突]]></title>
    <url>%2F%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3scrollView%E4%B8%AD%E6%81%BC%E4%BA%BA%E7%9A%84%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81.html</url>
    <content type="text"><![CDATA[开发一个界面较为复杂的app，我们势必会出现在scrollview或者tableview上加上按钮或者手势，But.. Cell中Button点击高亮反馈为何有阻滞？ 又是什么阻挡了我tableview的滑动（滑动失效）？ ScrollView手势处理原理一款优秀的产品势必要有优秀的点击反馈，但是为何你做的列表 快速点击了cell上的按钮没有高亮，点击时间延长了才有效果！？ UIScrollView原理，以时间为轴线： 从你的手指touch屏幕开始，scrollView开始一个timer，如果： 150ms内如果你的手指没有任何动作，消息就会传给subView。 150ms内手指有明显的滑动（一个swipe动作），scrollView就会滚动，消息不会传给subView。 150ms内手指没有滑动，scrollView将消息传给subView，但是之后手指开始滑动，scrollView传送touchesCancelled消息给subView，然后开始滚动。 UIScrollView有一个BOOL类型的tracking属性，用来返回用户是否已经触及内容并打算开始滚动,当手指触摸到UIScrollView内容的一瞬间，会产生下面的动作： 拦截触摸事件 tracking属性变为YES 一个内置的计时器开始生效，用来监控在极短的事件间隔内是否发生了手指移动 当检测到时间间隔内手指发生了移动，UIScrollView自己触发滚动，tracking属性变为NO，手指触摸下即使有(可以响应触摸事件的)内部控件也不会再响应触摸事件。 当检测到时间间隔内手指没有移动，tracking属性保持YES，手指触摸下如果有(可以响应触摸事件的)内部控件，则将触摸事件传递给控件进行处理。 当你手指放在按钮上，维持150ms，才会触发UIButton的触摸事件！ delaysContentTouches不过上面的工作原理其实有一个属性开关来控制：delaysContentTouches（默认YES） 只要将scrollview的这个属性设置为false，滚动视图将会第一时间处理响应者链的手势传递！ （按钮一点即亮～） 这时就会立刻执行touchesShouldBegin: withEvent: inContentView:方法！ （这个方法是最先接收到滑动事件的，优先于button的 UIControlEventTouchDown，以及- (void)touchesCancelled:(NSSet)touches withEvent:(UIEvent)event） 如果返回YES，touche事件沿着消息响应链传递; 如果返回NO，表示UIScrollView接收这个滚动事件，不必沿着消息响应链传递了。 touchesShouldCancelled:withEvent: 当我们正在触摸屏幕的时候，如果出现了低电量、有电话呼入等等这样的系统事件时候，低电量或者电话的窗口会置为前台，这个时候touchesCancelled方法就会被调用。这大多数是由iOS系统发出的一些事件，导致触摸事件的中断，一般情况下直接调用touchesEnd即可。 如果返回YES:(系统默认)是允许UIScrollView，按照消息响应链向子视图传递消息的 如果返回NO:UIScrollView,就接收不到滑动事件了。 canCancelContentTouches这个BOOL类型的值控制content view里的触摸是否总能引发跟踪(tracking)。（默认YES） 如果设置为NO，这消息一旦传递给subView，这scroll事件不会再发生。 如果属性值为YES并且跟踪到手指正触摸到一个内容控件，这时如果用户拖动手指的距离足够产生滚动，那么内容控件将收到一个touchesCancelled:withEvent:消息，而scroll view将这次触摸作为滚动来处理。如果值为NO，一旦content view开始跟踪(tracking==YES)，则无论手指是否移动，scrollView都不会滚动。 将按钮点击反馈出来为了使我的cell或者子控件上的按钮有点击效果，将delaysContentTouches设置为false，我的按钮重获了第一时间的反馈效果。 当delaysContentTouches设置为false之后，scrollview的滑动变得迟钝了。canCancelContentTouches属性感觉一直都是false的效果，当手指经过了button（有点击高亮效果）再移开，scrollview不会接收滑动事件，UIButton吃掉了我的手势！ ❓:不过我没有主动将canCancelContentTouches这个属性改为true，也许会有不一样的效果？ 修复滑动当将手指按下时，cell上的按钮会更改颜色，这会提供视觉反馈，以确认您抬起手指时将激活哪个按钮。 我需要：如果将手指从按钮上拖动，则抬起时触摸这个事件将被取消，并且该按钮的取消高亮显示，将手势变为滑动滚动scrollview。 这时我们的技巧是，重写上文中提到的，touchesShouldCancel(in:) ，自己决定是否允许滚动视图取消控件中的触摸！ 这里实现了一个scrollView, tableView, collectionView的父控件，他们可以防止UIButton或者某些不应该吃掉手势的控件作出不当的行为（但是最好还是保留UITextInput, UISlider, 以及UISwitch阻挡手势的权利）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import UIKit// These let you start a touch on a control that's inside a scroll view,// and then if you start dragging, it cancels the touch on the button// and lets you scroll instead. Without these scroll view subclasses,// controls in scroll views will eat touches that start in them, which// prevents scrolling and makes the app feel broken.//// The UITextInput exception is for cases where you have a text field// or a text view in a scroll view. If you press and hold there, you want// to get the text editing magnifier cursor, instead of canceling the// touch in the text input element.//// Ditto for UISlider and UISwitch: if the table view eats the drag gesture,// they feel broken. Feel free to add your own exceptions if you have custom// controls that require swiping or dragging to function.final class ControlContainableScrollView: UIScrollView &#123; override func touchesShouldCancel(in view: UIView) -&gt; Bool &#123; if view is UIControl &amp;&amp; !(view is UITextInput) &amp;&amp; !(view is UISlider) &amp;&amp; !(view is UISwitch) &#123; return true &#125; return super.touchesShouldCancel(in: view) &#125;&#125;final class ControlContainableTableView: UITableView &#123; override func touchesShouldCancel(in view: UIView) -&gt; Bool &#123; if view is UIControl &amp;&amp; !(view is UITextInput) &amp;&amp; !(view is UISlider) &amp;&amp; !(view is UISwitch) &#123; return true &#125; return super.touchesShouldCancel(in: view) &#125;&#125;final class ControlContainableCollectionView: UICollectionView &#123; override func touchesShouldCancel(in view: UIView) -&gt; Bool &#123; if view is UIControl &amp;&amp; !(view is UITextInput) &amp;&amp; !(view is UISlider) &amp;&amp; !(view is UISwitch) &#123; return true &#125; return super.touchesShouldCancel(in: view) &#125;&#125; 只要使用了这个两个技巧，你能保留scrollview上交互控件的良好点击反馈，又能像原生tableview一样自然的滑动取消点击cell的高亮并且变成滚动scrollview，带来更自然更好的用户体验哇！ UIGestureRecognizerDelegate当你需要在scrollView上加上滑动手势的时候，那么更加会遇到滑动手势冲突的情况。 需求 上滑的时候，先不让子scrollView滑动（更改contentOffsetY为0），而是隐藏头部内容控件，再让子scrollView开始滑动 下滑的时候，等子scrollView滑到最上方之后（contentOffsetY为0），再允许父ScrollView滑动，显示头部控件 实现 创建UIScrollView的子类，实现代理UIGestureRecognizerDelegate的gestureRecognizer(_:shouldRecognizeSimultaneouslyWith:)方法；返回true，让滑动事件可以向父View传递： 12345class myScrollView: UIScrollView, UIGestureRecognizerDelegate &#123; func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -&gt; Bool &#123; return true &#125;&#125; 实现代理方法：（例子） 1234567891011121314151617181920212223extension CollisionViewController: UIScrollViewDelegate &#123; func scrollViewWillBeginDragging(_ scrollView: UIScrollView) &#123; if scrollView == self.scrollView &#123; lastOffsetY = self.scrollView.contentOffset.y &#125; &#125; func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; if scrollView == self.scrollView &#123; let y = (self.view.superview?.superview?.superview?.y)! - PageViewControllerPlus.topNaviBarHeight if self.scrollView.contentOffset.y &gt; lastOffsetY &#123; // 下滑 if superContainerScrollView!.contentOffset.y &lt;= y &#123; self.scrollView.contentOffset.y = 0 &#125; &#125; else if self.scrollView.contentOffset.y &lt; lastOffsetY &#123; //上滑 if self.scrollView.contentOffset.y &gt; 0 &#123; superContainerScrollView?.contentOffset.y = y + PageViewControllerPlus.topNaviBarHeight &#125; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开发之术</tag>
        <tag>ScrollView</tag>
        <tag>TableView</tag>
        <tag>手势</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不止配置ssh实现Sourcetree密钥访问远程仓库]]></title>
    <url>%2F%E4%B8%8D%E6%AD%A2%E9%85%8D%E7%BD%AEssh%E5%AE%9E%E7%8E%B0Sourcetree%E5%AF%86%E9%92%A5%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.html</url>
    <content type="text"><![CDATA[每次推拉合并代码到远程仓库都需要输入账号密码，那也太慢了太糗了吧？ 配置好了ssh私钥，但是为何报错port 22: Connection refused呢？ 终于免密操作了，咋电脑重启又不不好使了？ 背景团队实施了组件化开发，项目分成多个组件。 难以避免的会频繁使用pod及远程仓库操作，每天十来位同事在疯狂输出，一不留神项目git就几十个更新，如果每次pull/rebase/merge/push/代码都需要输入账号密码，那绝对1000%影响开发进度。 配置ssh “SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 几乎每一个远程仓库服务商（github, gitlab, bitbucket…）都有如何生成以及将密钥配置到远程仓库的教程，这里简单看看步骤 常规操作 生成新的ssh key 1ssh-keygen -t rsa -b 4096 -C "your_email@example.com" 或查看已存在的key 1ls -al ~/.ssh 将您的SSH私钥添加到ssh-agent（该agent为您实现身份验证操作哦）并将密码短语存储在Mac钥匙串中 1ssh-add -K ~/.ssh/id_rsa 将ssh密钥复制到剪贴板后，粘到远程仓库的配置中 1pbcopy &lt; ~/.ssh/id_rsa.pub -K选项是Apple的标准版本ssh-add，当您将ssh密钥添加到ssh-agent时，它将密码短语存储在您的钥匙串中 报错：ssh: connect to host gitlab.com port 22: Connection refused你已经将私钥添加到了代理和钥匙串，远程也配置好了，然鹅不管终端还是sourcetree操作还是会报错。 测试链接，如下是假如你想配置多个平台.. 此时你输入哪一个都会报错 123ssh -T git@github.comssh -T bitbucket.orgssh -T 192.160.2.xxx //工作的私有远程仓库 为什么呢？ 如果您使用的是macOS Sierra 10.12.2或更高版本，需要~/.ssh/config文件以将密钥自动加载到ssh-agent中，并将密码短语存储在密钥链中 也就是说ssh-add还不够，我还需要配置ssh的config文件，config文件涉及到很多不同字段有不同的作用，可以在：SSH的config配置之多账号简单管理，学习一哈！ 最后，根据我的需求，创建&amp;编辑了一个config文件，不同网站对应了不同的key： 123456789101112131415161718192021# GithubHost opensource Hostname ssh.github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github User xxxxx@xx.com # BitbucketHost private HostName bitbucket.org Preferredauthentications publickey IdentityFile ~/.ssh/id_ed25519_bb User git# Private GitLab instanceHost work HostName 192.160.2.xxx port 1888 Preferredauthentications publickey IdentityFile ~/.ssh/id_rsa_work User git 报错：Bad owner or permissions on ~/xxx/.ssh/config配置完config文件，再次通过ssh -T测试连接，却又报错，这次是配置文件的权限不够，我们给他权限 1sudo chmod 600 ~/xxx/.ssh/config 再次连接就成功了，会提示你successfully autheticated或者Hi ,welcome to XXX。 通过ssh这个通行证，您可以用sourcetree任意玩耍不再需要输入账号密码，也不再需要输入密钥的安全码了！😄 重启了Mac，sourcetree操作又报权限错误soucetree为啥会报错呢，因为他操作命令是不会帮你输入密码的，也就是rsa密钥的安全码！ 当用你用terminal操作git你就会发现，又需要输入rsa的passphase了。 在重启之后，ssh-agent估计（可能？）也是重启了，于是密钥丢失了。 意味着每次重启Mac你就要去执行ssh-add -K！ 我们把这几个命令自动化吧，在每次启动时执行shell，步骤： 找到自动操作.app，创建一个Automator 应用程序 选择“运行shell脚本”，输入命令，点击顶部未命名保存 系统偏好设置-&gt;用户与群组-&gt;登录项，选择我们保存的app文件，实现开机自启动]]></content>
      <tags>
        <tag>shell</tag>
        <tag>ssh</tag>
        <tag>Sourcetree</tag>
        <tag>Automator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS检测企业包(.ipa)掉签脚本]]></title>
    <url>%2FiOS%E6%A3%80%E6%B5%8B%E4%BC%81%E4%B8%9A%E5%8C%85(.ipa)%E6%8E%89%E7%AD%BE%E8%84%9A%E6%9C%AC.html</url>
    <content type="text"><![CDATA[“客户装不上app啦！”“客户打开app闪退啦！”“ios检查一下是不是掉签啦！” 遇到企业证书被Revoke的情况，会导致已装好并且手动信任的企业包app打开闪退，或新用户装上app图标是灰色的。 太烦了，每次检查要重新下载安装一次确认，浪费时间，流量，又没有技术含量，不能每次都要因为这种问题浪费宝贵的时间，而且是否掉签我们作为开发要用事实&amp;数据说话！ 我们可以用Apple自带的codesign命令对app文件内的签名导出 再通过OpenSSL命令去检查证书的有效期 如果检查不到有效期或者显示了”Revoked”，自然表示签名不可用，也意味着证书挂了。参考了几篇文（找不到了），并弄了一个脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# USAGE: ./checkSign.sh &#123;ipa文件名：xxx.ipa&#125;# 看到⚠️证明该ipa证书签名有问题# 删除文件echo "🗑 删除codesign,pem,plist,和“Payload”文件夹及其子文件"if [ -d "Payload" ] ; thenrm -rf Payloadfirm -f codesign0rm -f codesign1rm -f codesign2rm -f *.pemrm -f *.plistrm -f iTunesArtwork# 参数检查canshu=$1ipaFile=$&#123;canshu##*/&#125;# 截取&amp;拼接.appappFile=$&#123;ipaFile%.*&#125;".app"islegal=$(echo $1 | grep ".ipa$")echo "👀 请检查参数"echo "ipa: $ipaFile"echo "app: $appFile"if [ -n "$islegal" ]; then if [ ! -f "$ipaFile" ]; then echo "❌ “$1”文件不存在，结束进程" exit 0 fielse echo "❌ 参数格式必须是文件全名:xxx.ipa，结束进程" exit 0fi# 解压unzip -q $ipaFile# 导出签名codesign -dvv --extract-certificates Payload/*.appif [ ! -f "codesign0" ] || [ ! -f "codesign1" ] || [ ! -f "codesign2" ]; then echo "⚠️ 导出codesign完整3个文件失败，该ipa文件证书过期或者被损坏" #TODO: 可在这里做替换ipa操作else openssl x509 c-inform DER -in codesign0 -out codesign0.pem openssl x509 -inform DER -in codesign1 -out codesign1.pem openssl x509 -inform DER -in codesign2 -out codesign2.pem cat codesign1.pem codesign2.pem &gt; cachain.pem openssl x509 -inform DER -in codesign0 -noout -nameopt -oneline -subject -serial -dates if openssl ocsp -issuer cachain.pem -cert codesign0.pem -url `openssl x509 -in codesign0.pem -noout -ocsp_uri` -CAfile cachain.pem -header 'host' 'ocsp.apple.com' | grep revoked ; then echo "⚠️ 证书被Revoke，请替换" #TODO: 可在这里做替换ipa操作 else echo "💯执行完毕，该ipa包证书可用" fifi 这个脚本可以丢给运维，让他做定时检查，他还可以做掉签报警和切换等..以后掉签问题问运维，不要再来问我啦～（别打扰我摸鱼）]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>企业签名</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS应用内检测网络连接是否开启代理(VPN)]]></title>
    <url>%2FiOS%E5%BA%94%E7%94%A8%E5%86%85%E6%A3%80%E6%B5%8B%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E4%BB%A3%E7%90%86-VPN.html</url>
    <content type="text"><![CDATA[2020年我要学习网络安全咯！ 有时候在开发中会遇到这样的需求： 我们需要检测用户的网络IP地址是否开启了代理（VPN），防止一些用户通过关闭GPS，让我们的IP定位错误，非法获取我们限制了地域的优惠，或者是传递虚假网络信息。 我们可以通过判断“tap tun ipsec ppp” 这些字段是否在“CFNetworkCopySystemProxySettings”里，来判断vpn是否开启。 完整方法在此： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253- (BOOL)isVPNOn&#123; BOOL flag = NO; NSString *version = [UIDevice currentDevice].systemVersion; // need two ways to judge this. if (version.doubleValue &gt;= 9.0) &#123; NSDictionary *dict = CFBridgingRelease(CFNetworkCopySystemProxySettings()); NSArray *keys = [dict[@"__SCOPED__"] allKeys]; for (NSString *key in keys) &#123; if ([key rangeOfString:@"tap"].location != NSNotFound || [key rangeOfString:@"tun"].location != NSNotFound || [key rangeOfString:@"ipsec"].location != NSNotFound || [key rangeOfString:@"ppp"].location != NSNotFound)&#123; flag = YES; break; &#125; &#125; &#125; else &#123; struct ifaddrs *interfaces = NULL; struct ifaddrs *temp_addr = NULL; int success = 0; // retrieve the current interfaces - returns 0 on success success = getifaddrs(&amp;interfaces); if (success == 0) &#123; // Loop through linked list of interfaces temp_addr = interfaces; while (temp_addr != NULL) &#123; NSString *string = [NSString stringWithFormat:@"%s" , temp_addr-&gt;ifa_name]; if ([string rangeOfString:@"tap"].location != NSNotFound || [string rangeOfString:@"tun"].location != NSNotFound || [string rangeOfString:@"ipsec"].location != NSNotFound || [string rangeOfString:@"ppp"].location != NSNotFound) &#123; flag = YES; break; &#125; temp_addr = temp_addr-&gt;ifa_next; &#125; &#125; // Free memory freeifaddrs(interfaces); &#125; return flag;&#125; 这个是判断系统的vpn状态，还有一种是调起vpnExtension或着说NEVPNManager的时候的vpn状态可以通过实例化NEVPNManager，然后通过manager.connection.status来获取当前的vpn状态。 该方法有一个缺陷，就是如果用户是连接了已经开启代理的Wi-Fi网络，那我们就无法检测到啦！如果有更好的方法欢迎留言告知～]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开发之术</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS WKWebView实现Post请求]]></title>
    <url>%2FiOS-WKWebView%E5%AE%9E%E7%8E%B0Post%E8%AF%B7%E6%B1%82.html</url>
    <content type="text"><![CDATA[（敲锣打鼓）ZF渠道的朋友又来搞事情了！ （听好了听好了）现在的需求是这样的！ 通过我们向服务器发起一个A请求，服务器返回一个URL以及所有需要的参数，我们再通过WebView发起Post请求的方式（其中有重定向跳转）拿到最后的HTML信息。 因为UIWebView有内存泄漏和严重的性能问题，本着喜新厌旧的本性，项目中的WebView已经全面转了WKWebView。 WKWebView fail to load post request第一次尝试，自定义了SURLRequest，将方法改为post，将参数转码，甚至还自定义了content-type，然鹅请求却失败。 12345NSMutableURLRequest * requestShare = [[NSMutableURLRequest alloc]initWithURL:[NSURL URLWithString:self.urlStr]] [request setHTTPMethod:@"POST"];[requset setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];[request setHTTPBody:[@"id=12&amp;name=Jhon&amp;token=skjasjlfjalsl" dataUsingEncoding:NSUTF8StringEncoding]]; //示例[self.wkwebview loadRequest:request]; 后来谷歌了..发现由于 WKWebView 在独立进程里执行网络请求。一旦注册 http(s) scheme 后，网络请求将从 Network Process 发送到 App Process，这样 NSURLProtocol 才能拦截网络请求。在 webkit2 的设计里使用 MessageQueue 进行进程之间的通信，Network Process 会将请求 encode 成一个 Message,然后通过 IPC 发送给 App Process。出于性能的原因，encode 的时候 HTTPBody 和 HTTPBodyStream 这两个字段被丢弃掉了！官方源码 苹果工程师对此也作出了回复， 回复文章中，苹果工程师还非常热心的告诉开发者，哈哈你的UIWebView能够发送Post请求也只是一个意外，我们根本就没想让你们这样玩！WebView只能通过GET请求建立，要不你们尝试用JavaScript发post请求耍耍呗。 JS大法好OC的不足就让JS来补足吧（怪押韵的？） 我们可以利用JS来动态的生成HTML里的form标签，然后用form表单来实现POST请求。而且WKWebView即使不加载任何html和request，也可以直接执行js方法（吊炸天了）。 我们将JS代码定义成一个即插即用的宏方法。 1234567891011121314151617#define POST_JS @"function my_post(path, params) &#123;\var method = \"POST\";\var form = document.createElement(\"form\");\form.setAttribute(\"method\", method);\form.setAttribute(\"action\", path);\for(var key in params)&#123;\ if (params.hasOwnProperty(key)) &#123;\ var hiddenFild = document.createElement(\"input\");\ hiddenFild.setAttribute(\"type\", \"hidden\");\ hiddenFild.setAttribute(\"name\", key);\ hiddenFild.setAttribute(\"value\", params[key]);\ &#125;\ form.appendChild(hiddenFild);\&#125;\document.body.appendChild(form);\form.submit();\&#125;" 发送请求！ 123456// url - 请求发送的地址// paramStr - 要传递的参数,格式需要转成合法的json字符串,如：@"&#123;\"token\":\"cac6af340960485aa334416c8a34ddbf\"&#125;";// js - 需要wkwebView执行的JS代码，post一份form表单NSString * js = [NSString stringWithFormat:@"%@my_post(\"%@\", %@)",POST_JS,url,dataStr];[self.wkwebview evaluateJavaScript:js completionHandler:nil]; 嗯嗯，这样就太爽了。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>WKWebView</tag>
        <tag>开发之术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C中基础锁及其性能探究]]></title>
    <url>%2FObjective-C%E4%B8%AD%E5%9F%BA%E7%A1%80%E9%94%81%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E6%8E%A2%E7%A9%B6.html</url>
    <content type="text"><![CDATA[懂点锁，才能写好多线程。 线程锁我们在多线程中大展拳脚的时候，总可能会遇到资源争夺，导致数据混乱，线程锁这个时候可以为我们的数据资源保驾护航，在OC中基础的锁有@synchronized，NSLock，pthread，OSSpinLock。 我们先构建一个类，假设当前它是我们的一个共享资源，且func1与func2是两个互斥的操作，如下： 1234567@implementation TokenObj- (void)func1&#123; //读写操作1&#125;- (void)func2&#123; //读写操作2&#125; 然后，我们来看看如何使用以上四种锁实现在不同线程切换的时候锁住资源。 @synchronized1234567891011121314TokenObj *obj = [[TokenObj alloc] init];//线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; @synchronized(obj)&#123; [obj func1]; &#125;&#125;);//线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1);//以保证让线程2的代码后执行 @synchronized(obj)&#123; [obj func2]; &#125;&#125;); @synchronized指令中的token为该锁的唯一标识对象，该指令只对相同标识中的对象进行加锁。用@synchronized实现锁的优点就是不需要在代码中显式地创建锁对象，便可以实现锁的机制，但是它会隐式地添加一个异常处理例程（该历处理例程会在异常抛出的时候自动释放互斥锁）来保护代码。因此该指令会因为该例程带来额外的内存开销，下面我们对比性能的时候就能看到。 NSLock123456789101112131415TokenObj *obj = [[TokenObj alloc] init];NSLock *lock = [[NSLock alloc] init];//线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [lock lock]; [obj func1]; [lock unlock];&#125;);//线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); [lock lock]; [obj func2]; [lock unlock];&#125;); NSLock是Cocoa提供给我们最基本的锁对象，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。 pthread1234567891011121314TokenObj *obj = [[TokenObj alloc] init];__block pthread_mutex_t mutex;pthread_mutex_init(&amp;mutex, NULL);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;mutex); [obj func1]; pthread_mutex_unlock(&amp;mutex);&#125;);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); pthread_mutex_lock(&amp;mutex); [obj func2]; pthread_mutex_unlock(&amp;mutex);&#125;); pthread_mutex_t是C语言模块，在使用时要引用”pthread.h”。 dispatch_semaphore 实现锁以上代码构建多线程我们就已经用到了GCD的dispatch_async方法，其实在GCD中也已经提供了一种信号机制，使用它我们也可以来构建一把”锁”(从本质意义上讲，信号量与锁是有区别，具体差异参加信号量与互斥锁之间的区别) 123456789101112131415TokenObj *obj = [TokenObj alloc] init];dispatch_semaphore semaphore = dispatch_semaphore_create(1);//线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [obj func1]; dispatch_semaphore_signal(semaphore);&#125;);//线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [obj func2]; dispatch_semaphore_signal(semaphore);&#125;); 可以去了解一下dispatch_semaphore。 OSSpinLock (deprecated)12345678910111213TokenObj *obj = [[TokenObj alloc] init];OSSpinLock spinlock = OS_SPINLOCK_INIT;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; OSSpinLockLock(&amp;spinlock); [obj func1]; OSSpinLockUnlock(&amp;spinlock);&#125;);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); OSSpinLockLock(&amp;spinlock); [obj func2]; OSSpinLockUnlock(&amp;spinlock);&#125;); OSSpinLock因为存在安全问题，在iOS10.0以后就被弃用了，可以使用os_unfair_lock_lock替代（除了 OSSpinLock 外，dispatch_semaphore 和 pthread_mutex 性能是最高的）。具体参考：不再安全的 OSSpinLock。 性能探究12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#import &lt;libkern/OSAtomic.h&gt;#import &lt;pthread.h&gt;#define ITERATIONS (1024*1024*32)static unsigned long long disp=0, land=0;int main()&#123; double then, now; unsigned int i, count; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; OSSpinLock spinlock = OS_SPINLOCK_INIT; NSAutoreleasePool *pool = [NSAutoreleasePool new]; NSLock *lock = [NSLock new]; then = CFAbsoluteTimeGetCurrent(); for(i=0;i&lt;ITERATIONS;++i) &#123; [lock lock]; [lock unlock]; &#125; now = CFAbsoluteTimeGetCurrent(); printf("NSLock: %f sec\n", now-then); then = CFAbsoluteTimeGetCurrent(); IMP lockLock = [lock methodForSelector:@selector(lock)]; IMP unlockLock = [lock methodForSelector:@selector(unlock)]; for(i=0;i&lt;ITERATIONS;++i) &#123; lockLock(lock,@selector(lock)); unlockLock(lock,@selector(unlock)); &#125; now = CFAbsoluteTimeGetCurrent(); printf("NSLock+IMP Cache: %f sec\n", now-then); then = CFAbsoluteTimeGetCurrent(); for(i=0;i&lt;ITERATIONS;++i) &#123; pthread_mutex_lock(&amp;mutex); pthread_mutex_unlock(&amp;mutex); &#125; now = CFAbsoluteTimeGetCurrent(); printf("pthread_mutex: %f sec\n", now-then); then = CFAbsoluteTimeGetCurrent(); for(i=0;i&lt;ITERATIONS;++i) &#123; OSSpinLockLock(&amp;spinlock); OSSpinLockUnlock(&amp;spinlock); &#125; now = CFAbsoluteTimeGetCurrent(); printf("OSSpinlock: %f sec\n", now-then); id obj = [NSObject new]; then = CFAbsoluteTimeGetCurrent(); for(i=0;i&lt;ITERATIONS;++i) &#123; @synchronized(obj) &#123; &#125; &#125; now = CFAbsoluteTimeGetCurrent(); printf("@synchronized: %f sec\n", now-then); [pool release]; return 0;&#125; 用以上代码分别对四种基础锁的性能进行探究。代码中我们简单地加锁解锁重复33554432次，然后计算前后消耗时间，排除了自动释放池的影响。运行几次并取平均值统计出下图： @synchronized必须设置一个异常处理程序，它实际上最终会在那里采取一些内部锁。为了获得可锁定的锁而支付几个加锁解锁的费用。除了少写几行代码，带来的额外开销是其它锁的消耗3倍以上。 OSSpinLock甚至没有进入内核 - 它只是不断重新加载锁，希望它被解锁。如果锁保持超过几纳秒，这是非常低效的。一方面它节省了昂贵的系统调用和几个上下文切换，但是因为iOS系统关于线程优先级的更新，破坏了SpinLock的机制，因此它也变得不再安全了。 NSLock是pthread的一个漂亮的包装器。因此使用它而不是pthread没有多大意义。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>线程锁</tag>
        <tag>多线程</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[atomic一定是线程安全的吗？]]></title>
    <url>%2Fatomic%E4%B8%80%E5%AE%9A%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F.html</url>
    <content type="text"><![CDATA[不是 线程安全在多线程同时工作的情况下，系统会给每条线程分配一个独立的栈空间，但是他们会公用堆里面的数据。通过运用线程锁和原子性等方法避免多条线程同时访问同一块内存变量造成的数据错误或者冲突。 atomic一定安全么？nonatomic的内存管理语义是非原子性的，非原子性的操作本来就是线程不安全的，而atomic的操作是原子性的，但是并不意味着它是线程安全的，它会增加正确的几率，能够更好的避免线程的错误，但是它仍然是线程不安全的。 atomic所说的线程安全只是保证了getter和setter存取方法的线程安全，并不能保证整个对象是线程安全的。 eg:当线程A进行写操作，这时其他线程的读或者写操作会因为该操作而等待。当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获得了在B线程中的值，这就破坏了线程安全，如果有线程C在A线程读操作前release了该属性，那么还会导致程序崩溃。所以仅仅使用atomic并不会使得线程安全，我们还要为线程添加lock来确保线程的安全。 而且，atomic比nonatomic的存取速度相差约20倍，因此在日常开发中一般都是使用nonatomic。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>基础知识</tag>
        <tag>atomic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[assign VS weak? __weak VS __block?]]></title>
    <url>%2Fassign-VS-weak-block-VS-weak.html</url>
    <content type="text"><![CDATA[零碎却不简单。 assignassign 用于基础类型的赋值，不改变属性的引用计数。如：NSInteger, CGFloat, int float double assign其实也可以用来修饰对象，但是你可不要轻易尝试。因为被assign修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil。如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。 weakweak 用于对象类型，不改变属性的引用计数，当该对象被释放的时候，该弱引用的属性自动失效并且被赋值为nil，该属性可以避免循环引用问题。 __weak__weak是所有权修饰符，被修饰的变量在使用结束后会被释放。(不会在block代码块中被retain)所有权修饰符包括: __strong, __weak, __unsafe_unretained, __autorealease。 使用__unsafe_unretained 和 __weak都可以避免循环引用的问题，但由于前者是unsafe的，会造成野指针问题，所以尽量少用unsafe_unretained关键字 __block__block用于指明当前变量可以在block内部进行修改（ARC下会被retain）。 因为在block申明的同时会捕获该block所使用的全部自动变量的值，仅有使用权没有修改权利，使用了__block关键字修饰后的变量可以在block内部进行修改。 在block内，要避免循环引用要使用： 1__weak__typeof(self)weakSelf =self; 并且，在使用到self之后的对象或者属性防止在使用之前被析构引发不可预测的问题，所以要使用strong再把它持有一下。 1__strong__typeof(weakSelf)strongSelf = weakSelf; 易混淆点若 object 本身沒有去 retain 这个 block (即block不是某个对象的property)，則可以直接在 block 中使用 self。比如自定义的block块（一个匿名函数）在代码中执行；经常问到的animation动画是否需要使用weakblock的问题。 事实上大多數的 iOS 原生套件，以及 GCD 的 block 是不會造成 retain cycle 的，因为他们并沒有去 retain block。 特别要注意的是，讲一个变量直接定义为实例变量而非属性的时候，在block中使用时还是会retain到self导致循环引用，因为ivar也是self的一部分： 1234567@interface XXXViewController () &#123; NSString *str;&#125;self.completionHandler = ^&#123; // 直接引用就相当于 self-&gt;str NSLog(@"%@", str);&#125; 但是！ivar是无法用weakSelf去取值的，因此这里正确的做法还是要用到weakSelf和strongSelf的帮助： 12345__weak __typeof(self) weakSelf = self;self.completionHandler = ^&#123; __strong __typeof(weakSelf) strongSelf = weakSelf; NSLog(@"%@", strongSelf-&gt;str);&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>基础知识</tag>
        <tag>修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS内存管理原理浅谈]]></title>
    <url>%2FiOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88.html</url>
    <content type="text"><![CDATA[iOS的内存管理策略是什么？ ARC又是为了什么而诞生的？ 来自面试官的拷问 2011 年，苹果在 WWDC 大会上提出了自动的引用计数（ARC）。ARC 背后的原理是依赖编译器的静态分析能力，通过在编译时找出合理的位置，自动插入引用计数管理代码，从而彻底解放被内存管理禁锢的码农iOS开发者。 引用计数原理引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。 当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象是，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。 解决的问题在没有引用计数的情况下，一般内存管理的原则是 “谁申请谁释放”，但是当多个对象需要引用到某一个X对象/变量时，哪些对象需要长时间使用X对象，都会遇到谁来销毁X对象的问题。引用计数的出现，使得对象在被创建和使用时retain count +1，使用完后-1，对象的生命周期就可以交给引用计数来记录。 不要向已经释放的对象发送消息当某个对象的内存已经被回收，但是我们没有对他置空(nil)，仍然向它发送消息时，如果该内存被复用了，很可能会造成程序异常崩溃，也被称为僵尸对象或者野指针异常。 ARCARC 能解决 iOS 开发中 “极大部分” 的内存管理问题，但是开发者仍然需要注意： iOS 底层的 ** Core Foundation 对象 ** 不在 ARC 的管理下，需要手工管理它们的引用计数。 避免循环引用问题。 block及delegate的内存管理。 循环引用引用计数这种管理内存的方式有一个比较大的瑕疵，即不能很好的解决循环引用（Reference Cycle）问题。 对象 A 和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。这两个对象的销毁依赖于对方的销毁，即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。 多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，这种情况更难被发现。 主动断开如果程序员明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。例如如下一个引用链： Controller 持有了网络请求对象 网络请求对象持有了回调的 block 回调的 block 里面使用了 self（即持有了 Controller） 解决办法就是，在网络请求结束，网络请求对象执行完 block 之后，主动释放对于 block 的持有，以便打破循环引用。（xxx.Block = nil） 弱引用弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。 在 iOS 开发中，弱引用通常在 delegate 模式中使用，View Controller 的 delegate 成员变量通常是一个弱引用，以避免两个 ViewController 造成循环引用问题，例如tableView的delegate。 弱引用的实现原理系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。 从原理我们得知，弱引用的使用是有额外开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用，因为： 当我们在创建这个对象时，如果临时使用一个弱引用持有它，就会因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。 大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。 Xcode 检测循环引用在 Xcode 的菜单栏选择：Product -&gt; Profile，然后选择 “Leaks”，再点击右下角的”Profile” 按钮开始检测。 我们在模拟器里进行一些界面的切换。如果出现了内存泄漏，就可以在 Instruments 中看到红色的带”x”的图标写着“n new leaks”.. 点击 “Leaks Checks” 栏，再点击”Cycles &amp; Roots”，就可以看到以图形方式显示出来的循环引用。可以比较方便地找到循环引用的对象了。如图：]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>基础知识</tag>
        <tag>ARC</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“git add .” not worked - “诡异”问题解决]]></title>
    <url>%2F%E2%80%9Cgit-add-%E2%80%9D-not-worked-%E2%80%9C%E8%AF%A1%E5%BC%82%E2%80%9D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html</url>
    <content type="text"><![CDATA[听终端的话，别留下warning。 1234567891011$ git add .$ git commit -m "fuckit"On branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) (commit or discard the untracked or modified content in submodules) modified: xxx/themes/next (modified content, untracked content)no changes added to commit (use "git add" and/or "git commit -a") 起因自从把博客源码托管到github仓库之后，腰也不酸了，腿也不痛了，一口气上五楼..咳咳 之后我给hexo换了一个NEXT主题，爽炸了！可是今天修改了主题某个js文件，“git status”之后却显示“nothing to commit” ??? 上github上看源码仓库，却发现主题文件夹下空空如也..仓库却显示没问题，git log，一直停留在上个提交版本。 于是一直死循环操作“git add .”&amp;&amp;“git commit -m “xxx””，终端却一直无情回复我“Changes not staged for commit”，如上面那段代码所示。 尝试按照终端提示的办法无法解决。 这就很诡异了？于是我花了一个晚上疯狂踩坑.. 爬坑搜索了各个关键词句，看了stackoverflow和几篇无用博文还是没有找到合适的解决。直觉是文件引入的问题，一口气把next文件 “git rm –f xxx/themes/next” 再add进去，仔细一看却发现有如下提示： 123456789101112131415$ git add .warning: adding embedded git repository: xxx/themes/nexthint: You've added another git repository inside your current repository.hint: Clones of the outer repository will not contain the contents ofhint: the embedded repository and will not know how to obtain it.hint: If you meant to add a submodule, use:hint:hint: git submodule add &lt;url&gt; xxx/themes/nexthint:hint: If you added this path by mistake, you can remove it from thehint: index with:hint:hint: git rm --cached xxx/themes/nexthint:hint: See "git help submodule" for more information. 还好我认识一点英文，想起当时是从git仓库直接克隆next的，却因为粗心没有看warning，径直commit了（居然也没事- -!），才会引发以上的惨剧。于是乎赶紧把主题下的git仓库删除了。 偷了个懒，把next文件夹移走，commit，再移进来，add之后总算能看到一排排的主题相关文件辣～ 总结git仓库下要提交A文件夹，A/B文件夹下也包含一个git仓库（.git）。使用git add . 就只能加入一个空的B文件夹。 这个故事告诉我们以LINUX“没有回应就是最好的回应”的尿性来说，还是好好看终端回复吧。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>debug</tag>
      </tags>
  </entry>
</search>
