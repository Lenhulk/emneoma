<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>不止配置ssh实现Sourcetree密钥访问远程仓库</title>
      <link href="/%E4%B8%8D%E6%AD%A2%E9%85%8D%E7%BD%AEssh%E5%AE%9E%E7%8E%B0Sourcetree%E5%AF%86%E9%92%A5%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.html"/>
      <url>/%E4%B8%8D%E6%AD%A2%E9%85%8D%E7%BD%AEssh%E5%AE%9E%E7%8E%B0Sourcetree%E5%AF%86%E9%92%A5%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>每次推拉合并代码到远程仓库都需要输入账号密码，那也太慢了太糗了吧？</p><p>配置好了ssh私钥，但是为何报错port 22: Connection refused呢？</p><p>终于免密操作了，咋电脑重启又不不好使了？</p></blockquote><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>团队实施了组件化开发，项目分成多个组件。</p><p>难以避免的会频繁使用pod及远程仓库操作，每天十来位同事在疯狂输出，一不留神项目git就几十个更新，如果每次pull/rebase/merge/push/代码都需要输入账号密码，那绝对1000%影响开发进度。</p><h1 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h1><blockquote><p>“SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。</p></blockquote><p>几乎每一个远程仓库服务商（github, gitlab, bitbucket…）都有如何生成以及将密钥配置到远程仓库的<a href="https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh" target="_blank" rel="noopener">教程</a>，这里简单看看步骤</p><h3 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h3><ul><li><p>生成新的ssh key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C "your_email@example.com"</span><br></pre></td></tr></table></figure></li><li><p>或查看已存在的key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al ~/.ssh</span><br></pre></td></tr></table></figure></li><li><p>将您的SSH私钥添加到ssh-agent（该agent为您实现身份验证操作哦）并将密码短语存储在Mac钥匙串中</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -K ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></li><li><p>将ssh密钥复制到剪贴板后，粘到远程仓库的配置中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbcopy &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>-K</code>选项是Apple的标准版本<code>ssh-add</code>，当您将ssh密钥添加到ssh-agent时，它将密码短语存储在您的钥匙串中</p></blockquote><h3 id="报错：ssh-connect-to-host-gitlab-com-port-22-Connection-refused"><a href="#报错：ssh-connect-to-host-gitlab-com-port-22-Connection-refused" class="headerlink" title="报错：ssh: connect to host gitlab.com port 22: Connection refused"></a>报错：ssh: connect to host gitlab.com port 22: Connection refused</h3><p>你已经将私钥添加到了代理和钥匙串，远程也配置好了，然鹅不管终端还是sourcetree操作还是会报错。</p><ul><li><p>测试链接，如下是假如你想配置多个平台.. 此时你输入哪一个都会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">ssh -T bitbucket.org</span><br><span class="line">ssh -T 192.160.2.xxx   //工作的私有远程仓库</span><br></pre></td></tr></table></figure><p>为什么呢？</p><blockquote><p>如果您使用的是macOS Sierra 10.12.2或更高版本，需要<code>~/.ssh/config</code>文件以将密钥自动加载到ssh-agent中，并将密码短语存储在密钥链中</p></blockquote></li></ul><p>也就是说ssh-add还不够，我还需要配置ssh的config文件，config文件涉及到很多不同字段有不同的作用，可以在：<a href="https://jingwei.link/2018/12/15/ssh-config-multi-app-manager.html" target="_blank" rel="noopener">SSH的config配置之多账号简单管理</a>，学习一哈！</p><p>最后，根据我的需求，创建&amp;编辑了一个config文件，不同网站对应了不同的key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Github</span><br><span class="line">Host opensource   </span><br><span class="line">  Hostname ssh.github.com  </span><br><span class="line">  PreferredAuthentications publickey  </span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line">  User xxxxx@xx.com </span><br><span class="line">  </span><br><span class="line"># Bitbucket</span><br><span class="line">Host private</span><br><span class="line">  HostName bitbucket.org</span><br><span class="line">  Preferredauthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/id_ed25519_bb</span><br><span class="line">  User git</span><br><span class="line"></span><br><span class="line"># Private GitLab instance</span><br><span class="line">Host work</span><br><span class="line">  HostName 192.160.2.xxx</span><br><span class="line">  port 1888</span><br><span class="line">  Preferredauthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_work</span><br><span class="line">  User git</span><br></pre></td></tr></table></figure><h3 id="报错：Bad-owner-or-permissions-on-xxx-ssh-config"><a href="#报错：Bad-owner-or-permissions-on-xxx-ssh-config" class="headerlink" title="报错：Bad owner or permissions on ~/xxx/.ssh/config"></a>报错：Bad owner or permissions on ~/xxx/.ssh/config</h3><p>配置完config文件，再次通过ssh -T测试连接，却又报错，这次是配置文件的权限不够，我们给他权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 600 ~/xxx/.ssh/config</span><br></pre></td></tr></table></figure><p>再次连接就成功了，会提示你successfully autheticated或者Hi ,welcome to XXX。</p><p>通过ssh这个通行证，您可以用sourcetree任意玩耍不再需要输入账号密码，也不再需要输入密钥的安全码了！😄</p><hr><h2 id="重启了Mac，sourcetree操作又报权限错误"><a href="#重启了Mac，sourcetree操作又报权限错误" class="headerlink" title="重启了Mac，sourcetree操作又报权限错误"></a>重启了Mac，sourcetree操作又报权限错误</h2><p>soucetree为啥会报错呢，因为他操作命令是不会帮你输入密码的，也就是rsa密钥的安全码！</p><p>当用你用terminal操作git你就会发现，又需要输入rsa的passphase了。</p><p>在重启之后，ssh-agent估计（可能？）也是重启了，于是密钥丢失了。</p><p>意味着每次重启Mac你就要去执行ssh-add -K！</p><p>我们把这几个命令自动化吧，在每次启动时执行shell，步骤：</p><ol><li>找到自动操作.app，创建一个Automator 应用程序</li></ol><p><img src="https://s2.ax1x.com/2019/12/15/QWBxMj.png" alt="1"></p><ol start="2"><li>选择“运行shell脚本”，输入命令，点击顶部未命名保存</li></ol><p><img src="https://s2.ax1x.com/2019/12/15/QWBjzQ.png" alt="2"></p><ol start="3"><li><p>系统偏好设置-&gt;用户与群组-&gt;登录项，选择我们保存的app文件，实现开机自启动</p><p><img src="https://s2.ax1x.com/2019/12/15/QWBXRg.png" alt="3"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> shell </tag>
            
            <tag> Sourcetree </tag>
            
            <tag> Automator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS检测企业包(.ipa)掉签脚本</title>
      <link href="/iOS%E6%A3%80%E6%B5%8B%E4%BC%81%E4%B8%9A%E5%8C%85(.ipa)%E6%8E%89%E7%AD%BE%E8%84%9A%E6%9C%AC.html"/>
      <url>/iOS%E6%A3%80%E6%B5%8B%E4%BC%81%E4%B8%9A%E5%8C%85(.ipa)%E6%8E%89%E7%AD%BE%E8%84%9A%E6%9C%AC.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>“客户装不上app啦！”<br>“客户打开app闪退啦！”<br>“ios检查一下是不是掉签啦！”</p></blockquote><a id="more"></a><div class="note info"><p>遇到企业证书被Revoke的情况，会导致已装好并且手动信任的企业包app打开闪退，或新用户装上app图标是灰色的。</p></div><p>太烦了，每次检查要重新下载安装一次确认，浪费时间，流量，又没有技术含量，不能每次都要因为这种问题浪费宝贵的时间，而且是否掉签我们作为开发要用事实&amp;数据说话！</p><ul><li>我们可以用Apple自带的codesign命令对app文件内的签名导出</li><li>再通过OpenSSL命令去检查证书的有效期</li></ul><p>如果检查不到有效期或者显示了”Revoked”，自然表示签名不可用，也意味着证书挂了。<br>参考了几篇文（找不到了），并弄了一个脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> USAGE: ./checkSign.sh &#123;ipa文件名：xxx.ipa&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 看到⚠️证明该ipa证书签名有问题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除文件</span></span><br><span class="line">echo "🗑 删除codesign,pem,plist,和“Payload”文件夹及其子文件"</span><br><span class="line">if [ -d "Payload" ] ; then</span><br><span class="line">rm -rf Payload</span><br><span class="line">fi</span><br><span class="line">rm -f codesign0</span><br><span class="line">rm -f codesign1</span><br><span class="line">rm -f codesign2</span><br><span class="line">rm -f *.pem</span><br><span class="line">rm -f *.plist</span><br><span class="line">rm -f iTunesArtwork</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数检查</span></span><br><span class="line">canshu=$1</span><br><span class="line">ipaFile=$&#123;canshu##*/&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 截取&amp;拼接.app</span></span><br><span class="line">appFile=$&#123;ipaFile%.*&#125;".app"</span><br><span class="line">islegal=$(echo $1 | grep ".ipa$")</span><br><span class="line">echo "👀 请检查参数"</span><br><span class="line">echo "ipa: $ipaFile"</span><br><span class="line">echo "app: $appFile"</span><br><span class="line">if [ -n "$islegal" ]; then</span><br><span class="line">if [ ! -f "$ipaFile" ]; then</span><br><span class="line">echo "❌ “$1”文件不存在，结束进程"</span><br><span class="line">exit 0</span><br><span class="line">fi</span><br><span class="line">else</span><br><span class="line">echo "❌ 参数格式必须是文件全名:xxx.ipa，结束进程"</span><br><span class="line">exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">unzip -q $ipaFile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 导出签名</span></span><br><span class="line">codesign -dvv --extract-certificates Payload/*.app</span><br><span class="line">if [ ! -f "codesign0" ] || [ ! -f "codesign1" ] || [ ! -f "codesign2" ]; then</span><br><span class="line">echo "⚠️ 导出codesign完整3个文件失败，该ipa文件证书过期或者被损坏"</span><br><span class="line"><span class="meta">#</span><span class="bash">TODO: 可在这里做替换ipa操作</span></span><br><span class="line">else</span><br><span class="line">openssl x509 c-inform DER -in codesign0 -out codesign0.pem</span><br><span class="line">openssl x509 -inform DER -in codesign1 -out codesign1.pem</span><br><span class="line">openssl x509 -inform DER -in codesign2 -out codesign2.pem</span><br><span class="line">cat codesign1.pem codesign2.pem &gt; cachain.pem</span><br><span class="line">openssl x509 -inform DER -in codesign0 -noout -nameopt -oneline -subject -serial -dates</span><br><span class="line">if openssl ocsp -issuer cachain.pem -cert codesign0.pem -url `openssl x509 -in codesign0.pem -noout -ocsp_uri` -CAfile cachain.pem -header 'host' 'ocsp.apple.com' | grep revoked ; then</span><br><span class="line">    echo "⚠️ 证书被Revoke，请替换"</span><br><span class="line">    #TODO: 可在这里做替换ipa操作</span><br><span class="line">else</span><br><span class="line">    echo "💯执行完毕，该ipa包证书可用"</span><br><span class="line">fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>这个脚本可以丢给运维，让他做定时检查，他还可以做掉签报警和切换等..<br>以后掉签问题问运维，不要再来问我啦～（别打扰我摸鱼）</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> shell </tag>
            
            <tag> 企业签名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS应用内检测网络连接是否开启代理(VPN)</title>
      <link href="/iOS%E5%BA%94%E7%94%A8%E5%86%85%E6%A3%80%E6%B5%8B%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E4%BB%A3%E7%90%86-VPN.html"/>
      <url>/iOS%E5%BA%94%E7%94%A8%E5%86%85%E6%A3%80%E6%B5%8B%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E4%BB%A3%E7%90%86-VPN.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>标题我也不想取这么长…</p></blockquote><a id="more"></a><p>有时候在开发中会遇到这样的需求：</p><p><strong>我们需要检测用户的网络IP地址是否开启了代理（VPN），防止一些用户通过关闭GPS，让我们的IP定位错误，非法获取我们限制了地域的优惠，或者是传递虚假网络信息。</strong></p><div class="note primary">            <p>我们可以通过判断“<strong>tap</strong> <strong>tun</strong> <strong>ipsec</strong> <strong>ppp</strong>” 这些字段是否在“<strong>CFNetworkCopySystemProxySettings</strong>”里，来判断<strong>vpn</strong>是否开启。</p>          </div><p>完整方法在此：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isVPNOn</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">BOOL</span> flag = <span class="literal">NO</span>;</span><br><span class="line">   <span class="built_in">NSString</span> *version = [<span class="built_in">UIDevice</span> currentDevice].systemVersion;</span><br><span class="line">   <span class="comment">// need two ways to judge this.</span></span><br><span class="line">   <span class="keyword">if</span> (version.doubleValue &gt;= <span class="number">9.0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">NSDictionary</span> *dict = <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CFNetworkCopySystemProxySettings</span>());</span><br><span class="line">       <span class="built_in">NSArray</span> *keys = [dict[<span class="string">@"__SCOPED__"</span>] allKeys];</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> keys) &#123;</span><br><span class="line">           <span class="keyword">if</span> ([key rangeOfString:<span class="string">@"tap"</span>].location != <span class="built_in">NSNotFound</span> ||</span><br><span class="line">               [key rangeOfString:<span class="string">@"tun"</span>].location != <span class="built_in">NSNotFound</span> ||</span><br><span class="line">               [key rangeOfString:<span class="string">@"ipsec"</span>].location != <span class="built_in">NSNotFound</span> ||</span><br><span class="line">               [key rangeOfString:<span class="string">@"ppp"</span>].location != <span class="built_in">NSNotFound</span>)&#123;</span><br><span class="line">               flag = <span class="literal">YES</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">struct</span> ifaddrs *interfaces = <span class="literal">NULL</span>;</span><br><span class="line">       <span class="keyword">struct</span> ifaddrs *temp_addr = <span class="literal">NULL</span>;</span><br><span class="line">       <span class="keyword">int</span> success = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// retrieve the current interfaces - returns 0 on success</span></span><br><span class="line">       success = getifaddrs(&amp;interfaces);</span><br><span class="line">       <span class="keyword">if</span> (success == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// Loop through linked list of interfaces</span></span><br><span class="line">           temp_addr = interfaces;</span><br><span class="line">           <span class="keyword">while</span> (temp_addr != <span class="literal">NULL</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%s"</span> , temp_addr-&gt;ifa_name];</span><br><span class="line">               <span class="keyword">if</span> ([string rangeOfString:<span class="string">@"tap"</span>].location != <span class="built_in">NSNotFound</span> ||</span><br><span class="line">                   [string rangeOfString:<span class="string">@"tun"</span>].location != <span class="built_in">NSNotFound</span> ||</span><br><span class="line">                   [string rangeOfString:<span class="string">@"ipsec"</span>].location != <span class="built_in">NSNotFound</span> ||</span><br><span class="line">                   [string rangeOfString:<span class="string">@"ppp"</span>].location != <span class="built_in">NSNotFound</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   flag = <span class="literal">YES</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               temp_addr = temp_addr-&gt;ifa_next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// Free memory</span></span><br><span class="line">       freeifaddrs(interfaces);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是判断系统的vpn状态，还有一种是调起vpnExtension或着说NEVPNManager的时候的vpn状态可以通过实例化NEVPNManager，然后通过manager.connection.status来获取当前的vpn状态。</p><p>该方法有一个缺陷，就是如果用户是连接了已经开启代理的<strong>Wi-Fi</strong>网络，那我们就无法检测到啦！如果有更好的方法欢迎留言告知～</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 开发之术 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS WKWebView实现Post请求</title>
      <link href="/iOS-WKWebView%E5%AE%9E%E7%8E%B0Post%E8%AF%B7%E6%B1%82.html"/>
      <url>/iOS-WKWebView%E5%AE%9E%E7%8E%B0Post%E8%AF%B7%E6%B1%82.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>（敲锣打鼓）ZF渠道的朋友又来搞事情了！</p></blockquote><a id="more"></a><p>（听好了听好了）现在的需求是这样的！</p><blockquote><p>通过我们向服务器发起一个A请求，服务器返回一个URL以及所有需要的参数，我们再通过WebView发起Post请求的方式（其中有重定向跳转）拿到最后的HTML信息。</p></blockquote><p>因为UIWebView有内存泄漏和严重的性能问题，本着喜新厌旧的本性，项目中的WebView已经全面转了WKWebView。</p><h1 id="WKWebView-fail-to-load-post-request"><a href="#WKWebView-fail-to-load-post-request" class="headerlink" title="WKWebView fail to load post request"></a>WKWebView fail to load post request</h1><p>第一次尝试，自定义了SURLRequest，将方法改为post，将参数转码，甚至还自定义了content-type，然鹅请求却失败。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableURLRequest</span> * requestShare = [[<span class="built_in">NSMutableURLRequest</span> alloc]initWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span>.urlStr]] </span><br><span class="line">[request setHTTPMethod:<span class="string">@"POST"</span>];</span><br><span class="line">[requset setValue:<span class="string">@"application/x-www-form-urlencoded"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">[request setHTTPBody:[<span class="string">@"id=12&amp;name=Jhon&amp;token=skjasjlfjalsl"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]]; <span class="comment">//示例</span></span><br><span class="line">[<span class="keyword">self</span>.wkwebview loadRequest:request];</span><br></pre></td></tr></table></figure><p>后来谷歌了..发现由于 WKWebView 在独立进程里执行网络请求。一旦注册 http(s) scheme 后，网络请求将从 Network Process 发送到 App Process，这样 NSURLProtocol 才能拦截网络请求。在 webkit2 的设计里使用 MessageQueue 进行进程之间的通信，Network Process 会将请求 encode 成一个 Message,然后通过 IPC 发送给 App Process。出于性能的原因，encode 的时候 HTTPBody 和 HTTPBodyStream 这两个字段被丢弃掉了！<br><a href="https://github.com/WebKit/webkit/blob/fe39539b83d28751e86077b173abd5b7872ce3f9/Source/WebKit2/Shared/mac/WebCoreArgumentCodersMac.mm#L61-L88" target="_blank" rel="noopener">官方源码</a></p><p>苹果工程师对此也作出了<a href="https://forums.developer.apple.com/thread/18952" target="_blank" rel="noopener">回复</a>，回复文章中，苹果工程师还非常热心的告诉开发者，哈哈你的UIWebView能够发送Post请求也只是一个意外，我们根本就没想让你们这样玩！WebView只能通过GET请求建立，要不你们尝试用JavaScript发post请求耍耍呗。</p><h1 id="JS大法好"><a href="#JS大法好" class="headerlink" title="JS大法好"></a>JS大法好</h1><p>OC的不足就让JS来补足吧（怪押韵的？）</p><div class="note info">            <p>我们可以利用JS来动态的生成HTML里的form标签，然后用form表单来实现POST请求。<br>而且WKWebView即使不加载任何html和request，也可以直接执行js方法（吊炸天了）。</p>          </div><ol><li><strong>我们将JS代码定义成一个即插即用的宏方法。</strong></li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define POST_JS @<span class="meta-string">"function my_post(path, params) &#123;\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">var method = \"</span>POST\<span class="meta-string">";\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">var form = document.createElement(\"</span>form\<span class="meta-string">");\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">form.setAttribute(\"</span>method\<span class="meta-string">", method);\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">form.setAttribute(\"</span>action\<span class="meta-string">", path);\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">for(var key in params)&#123;\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    if (params.hasOwnProperty(key)) &#123;\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        var hiddenFild = document.createElement(\"</span>input\<span class="meta-string">");\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        hiddenFild.setAttribute(\"</span>type\<span class="meta-string">", \"</span>hidden\<span class="meta-string">");\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        hiddenFild.setAttribute(\"</span>name\<span class="meta-string">", key);\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        hiddenFild.setAttribute(\"</span>value\<span class="meta-string">", params[key]);\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    form.appendChild(hiddenFild);\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">document.body.appendChild(form);\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">form.submit();\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;"</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>发送请求！</strong></li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url - 请求发送的地址</span></span><br><span class="line"><span class="comment">// paramStr - 要传递的参数,格式需要转成合法的json字符串,如：@"&#123;\"token\":\"cac6af340960485aa334416c8a34ddbf\"&#125;";</span></span><br><span class="line"><span class="comment">// js - 需要wkwebView执行的JS代码，post一份form表单</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> * js = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@my_post(\"%@\", %@)"</span>,POST_JS,url,dataStr];</span><br><span class="line">[<span class="keyword">self</span>.wkwebview evaluateJavaScript:js completionHandler:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>嗯嗯，这样就太爽了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> WKWebView </tag>
            
            <tag> 开发之术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C中基础锁及其性能探究</title>
      <link href="/Objective-C%E4%B8%AD%E5%9F%BA%E7%A1%80%E9%94%81%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E6%8E%A2%E7%A9%B6.html"/>
      <url>/Objective-C%E4%B8%AD%E5%9F%BA%E7%A1%80%E9%94%81%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E6%8E%A2%E7%A9%B6.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>懂点锁，才能写好多线程。</p></blockquote><a id="more"></a><h2 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h2><p>我们在多线程中大展拳脚的时候，总可能会遇到资源争夺，导致数据混乱，线程锁这个时候可以为我们的数据资源保驾护航，在OC中基础的锁有@synchronized，NSLock，pthread，OSSpinLock。</p><p>我们先构建一个类，假设当前它是我们的一个共享资源，且func1与func2是两个互斥的操作，如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TokenObj</span></span></span><br><span class="line">- (<span class="keyword">void</span>)func1&#123;</span><br><span class="line"><span class="comment">//读写操作1</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)func2&#123;</span><br><span class="line"><span class="comment">//读写操作2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们来看看如何使用以上四种锁实现在不同线程切换的时候锁住资源。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TokenObj *obj = [[TokenObj alloc] init];</span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(obj)&#123;</span><br><span class="line">        [obj func1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//以保证让线程2的代码后执行</span></span><br><span class="line">    <span class="keyword">@synchronized</span>(obj)&#123;</span><br><span class="line">        [obj func2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>@synchronized指令中的token为该锁的唯一标识对象，该指令只对相同标识中的对象进行加锁。<br>用@synchronized实现锁的优点就是不需要在代码中显式地创建锁对象，便可以实现锁的机制，但是它会隐式地添加一个异常处理例程（该历处理例程会在异常抛出的时候自动释放互斥锁）来保护代码。因此该指令会因为该例程带来额外的内存开销，下面我们对比性能的时候就能看到。</p><h4 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TokenObj *obj = [[TokenObj alloc] init];</span><br><span class="line"><span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [lock lock];</span><br><span class="line">    [obj func1];</span><br><span class="line">    [lock unlock];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    [lock lock];</span><br><span class="line">    [obj func2];</span><br><span class="line">    [lock unlock];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>NSLock是Cocoa提供给我们最基本的锁对象，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。</p><h4 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TokenObj *obj = [[TokenObj alloc] init];</span><br><span class="line">__block pthread_mutex_t mutex;</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    [obj func1];</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    [obj func2];</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>pthread_mutex_t是C语言模块，在使用时要引用”pthread.h”。</p><h4 id="dispatch-semaphore-实现锁"><a href="#dispatch-semaphore-实现锁" class="headerlink" title="dispatch_semaphore 实现锁"></a>dispatch_semaphore 实现锁</h4><p>以上代码构建多线程我们就已经用到了GCD的dispatch_async方法，其实在GCD中也已经提供了一种信号机制，使用它我们也可以来构建一把”锁”(从本质意义上讲，信号量与锁是有区别，具体差异参加信号量与互斥锁之间的区别)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TokenObj *obj = [TokenObj alloc] init];</span><br><span class="line">dispatch_semaphore semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    [obj func1];</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    [obj func2];</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以去了解一下dispatch_semaphore。</p><h4 id="OSSpinLock-deprecated"><a href="#OSSpinLock-deprecated" class="headerlink" title="OSSpinLock (deprecated)"></a>OSSpinLock (deprecated)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TokenObj *obj = [[TokenObj alloc] init];</span><br><span class="line">OSSpinLock spinlock = OS_SPINLOCK_INIT;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    OSSpinLockLock(&amp;spinlock);</span><br><span class="line">    [obj func1];</span><br><span class="line">    OSSpinLockUnlock(&amp;spinlock);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">    OSSpinLockLock(&amp;spinlock);</span><br><span class="line">    [obj func2];</span><br><span class="line">    OSSpinLockUnlock(&amp;spinlock);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>OSSpinLock因为存在安全问题，在iOS10.0以后就被弃用了，可以使用os_unfair_lock_lock替代（除了 OSSpinLock 外，dispatch_semaphore 和 pthread_mutex 性能是最高的）。具体参考：<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a>。</p><h2 id="性能探究"><a href="#性能探究" class="headerlink" title="性能探究"></a>性能探究</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libkern/OSAtomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define ITERATIONS (1024*1024*32)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> disp=<span class="number">0</span>, land=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> then, now;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i, count;</span><br><span class="line">pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">OSSpinLock spinlock = OS_SPINLOCK_INIT;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [<span class="built_in">NSAutoreleasePool</span> new];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLock</span> *lock = [<span class="built_in">NSLock</span> new];</span><br><span class="line">then = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ITERATIONS;++i)</span><br><span class="line">&#123;</span><br><span class="line">[lock lock];</span><br><span class="line">[lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">now = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">printf(<span class="string">"NSLock: %f sec\n"</span>, now-then);    </span><br><span class="line"></span><br><span class="line">then = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">IMP lockLock = [lock methodForSelector:<span class="keyword">@selector</span>(lock)];</span><br><span class="line">IMP unlockLock = [lock methodForSelector:<span class="keyword">@selector</span>(unlock)];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ITERATIONS;++i)</span><br><span class="line">&#123;</span><br><span class="line">lockLock(lock,<span class="keyword">@selector</span>(lock));</span><br><span class="line">unlockLock(lock,<span class="keyword">@selector</span>(unlock));</span><br><span class="line">&#125;</span><br><span class="line">now = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">printf(<span class="string">"NSLock+IMP Cache: %f sec\n"</span>, now-then);    </span><br><span class="line"></span><br><span class="line">then = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ITERATIONS;++i)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">now = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">printf(<span class="string">"pthread_mutex: %f sec\n"</span>, now-then);</span><br><span class="line"></span><br><span class="line">then = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ITERATIONS;++i)</span><br><span class="line">&#123;</span><br><span class="line">OSSpinLockLock(&amp;spinlock);</span><br><span class="line">OSSpinLockUnlock(&amp;spinlock);</span><br><span class="line">&#125;</span><br><span class="line">now = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">printf(<span class="string">"OSSpinlock: %f sec\n"</span>, now-then);</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line"></span><br><span class="line">then = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ITERATIONS;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">@synchronized</span>(obj)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">now = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">printf(<span class="string">"@synchronized: %f sec\n"</span>, now-then);</span><br><span class="line"></span><br><span class="line">[pool release];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用以上代码分别对四种基础锁的性能进行探究。代码中我们简单地加锁解锁重复33554432次，然后计算前后消耗时间，排除了自动释放池的影响。运行几次并取平均值统计出下图：</p><p><img src="https://s2.ax1x.com/2019/07/07/ZB8lOs.png" alt="性能比较"></p><p>@synchronized必须设置一个异常处理程序，它实际上最终会在那里采取一些内部锁。为了获得可锁定的锁而支付几个加锁解锁的费用。除了少写几行代码，带来的额外开销是其它锁的消耗3倍以上。</p><p>OSSpinLock甚至没有进入内核 - 它只是不断重新加载锁，希望它被解锁。如果锁保持超过几纳秒，这是非常低效的。一方面它节省了昂贵的系统调用和几个上下文切换，但是因为iOS系统关于线程优先级的更新，破坏了SpinLock的机制，因此它也变得不再安全了。</p><p>NSLock是pthread的一个漂亮的包装器。因此使用它而不是pthread没有多大意义。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 线程锁 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>atomic一定是线程安全的吗？</title>
      <link href="/atomic%E4%B8%80%E5%AE%9A%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F.html"/>
      <url>/atomic%E4%B8%80%E5%AE%9A%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p><strong>不是</strong></p></blockquote><a id="more"></a><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>在多线程同时工作的情况下，系统会给每条线程分配一个独立的栈空间，但是他们会公用堆里面的数据。<br>通过运用线程锁和原子性等方法避免多条线程同时访问同一块内存变量造成的数据错误或者冲突。</p><h2 id="atomic一定安全么？"><a href="#atomic一定安全么？" class="headerlink" title="atomic一定安全么？"></a>atomic一定安全么？</h2><p>nonatomic的内存管理语义是非原子性的，非原子性的操作本来就是线程不安全的，而atomic的操作是原子性的，但是并不意味着它是线程安全的，它会增加正确的几率，能够更好的避免线程的错误，但是它仍然是线程不安全的。</p><p><em>atomic所说的线程安全只是保证了getter和setter存取方法的线程安全，并不能保证整个对象是线程安全的。</em></p><p>eg:当线程A进行写操作，这时其他线程的读或者写操作会因为该操作而等待。当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获得了在B线程中的值，这就破坏了线程安全，如果有线程C在A线程读操作前release了该属性，那么还会导致程序崩溃。所以仅仅使用atomic并不会使得线程安全，我们还要为线程添加lock来确保线程的安全。</p><p>而且，atomic比nonatomic的存取速度相差约20倍，因此在日常开发中一般都是使用nonatomic。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> atomic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>assign VS weak? __weak VS __block?</title>
      <link href="/assign-VS-weak-block-VS-weak.html"/>
      <url>/assign-VS-weak-block-VS-weak.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>零碎却不简单。</p></blockquote><a id="more"></a><h1 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h1><p><strong>assign</strong> 用于基础类型的赋值，不改变属性的引用计数。如：<em>NSInteger, CGFloat, int float double</em></p><blockquote><p>assign其实也可以用来修饰对象，但是你可不要轻易尝试。因为被assign修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil。如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。</p></blockquote><h1 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h1><p><strong>weak</strong> 用于对象类型，不改变属性的引用计数，当该对象被释放的时候，该弱引用的属性自动失效并且被赋值为<strong><em>nil</em></strong>，该属性可以避免循环引用问题。</p><h1 id="weak-1"><a href="#weak-1" class="headerlink" title="__weak"></a>__weak</h1><p><strong>__weak</strong>是所有权修饰符，被修饰的变量在使用结束后会被释放。(不会在block代码块中被retain)<br>所有权修饰符包括: <em>__strong,  __weak, __unsafe_unretained, __autorealease</em>。</p><blockquote><p>使用__unsafe_unretained 和 __weak都可以避免循环引用的问题，但由于前者是unsafe的，会造成野指针问题，所以尽量少用unsafe_unretained关键字</p></blockquote><h1 id="block"><a href="#block" class="headerlink" title="__block"></a>__block</h1><p><strong>__block</strong>用于指明当前变量可以在block内部进行修改（ARC下会被retain）。</p><blockquote><p>因为在block申明的同时会捕获该block所使用的全部自动变量的值，仅有使用权没有修改权利，使用了__block关键字修饰后的变量可以在block内部进行修改。</p></blockquote><p>在block内，要避免循环引用要使用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak__typeof(<span class="keyword">self</span>)weakSelf =<span class="keyword">self</span>;</span><br></pre></td></tr></table></figure><p>并且，在使用到self之后的对象或者属性防止在使用之前被析构引发不可预测的问题，所以要使用strong再把它持有一下。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__strong__typeof(weakSelf)strongSelf = weakSelf;</span><br></pre></td></tr></table></figure><h2 id="易混淆点"><a href="#易混淆点" class="headerlink" title="易混淆点"></a>易混淆点</h2><p>若 object 本身沒有去 retain 这个 block (即block不是某个对象的property)，則可以直接在 block 中使用 self。<br>比如自定义的block块（一个匿名函数）在代码中执行；经常问到的animation动画是否需要使用weakblock的问题。</p><div class="note default">事实上大多數的 iOS 原生套件，以及 GCD 的 block 是不會造成 retain cycle 的，因为他们并沒有去 retain block。</div><p>特别要注意的是，讲一个变量直接定义为实例变量而非属性的时候，在block中使用时还是会retain到self导致循环引用，因为ivar也是self的一部分：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXXViewController</span> () </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">self</span>.completionHandler = ^&#123;</span><br><span class="line">    <span class="comment">// 直接引用就相当于 self-&gt;str</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是！ivar是无法用weakSelf去取值的，因此<br>这里正确的做法还是要用到weakSelf和strongSelf的帮助：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.completionHandler = ^&#123;</span><br><span class="line">    __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, strongSelf-&gt;str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 修饰符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS内存管理原理浅谈</title>
      <link href="/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88.html"/>
      <url>/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>iOS的内存管理策略是什么？ ARC又是为了什么而诞生的？</p><p><strong>来自面试官的拷问</strong></p></blockquote><p><img src="https://s2.ax1x.com/2019/07/07/ZB8apF.jpg" alt="ZB8apF.jpg"></p><a id="more"></a><p><em>2011 年，苹果在 WWDC 大会上提出了自动的引用计数（ARC）。<br>ARC 背后的原理是依赖编译器的静态分析能力，通过在编译时找出合理的位置，自动插入引用计数管理代码，从而彻底解放被内存管理禁锢的<del>码农</del>iOS开发者。</em></p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。</p><p>当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象是，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。</p><p><img src="https://s2.ax1x.com/2019/07/07/ZB8r01.jpg" alt="ZB8r01.jpg"></p><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>在没有引用计数的情况下，一般内存管理的原则是 “谁申请谁释放”，但是当多个对象需要引用到某一个X对象/变量时，哪些对象需要长时间使用X对象，都会遇到谁来销毁X对象的问题。<br>引用计数的出现，使得对象在被创建和使用时<em>retain count</em> +1，使用完后-1，对象的生命周期就可以交给引用计数来记录。</p><h3 id="不要向已经释放的对象发送消息"><a href="#不要向已经释放的对象发送消息" class="headerlink" title="不要向已经释放的对象发送消息"></a>不要向已经释放的对象发送消息</h3><p>当某个对象的内存已经被回收，但是我们没有对他置空(nil)，仍然向它发送消息时，如果该内存被复用了，很可能会造成程序异常崩溃，也被称为僵尸对象或者野指针异常。</p><h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><p>ARC 能解决 iOS 开发中 “极大部分” 的内存管理问题，但是开发者仍然需要注意：</p><ul><li>iOS 底层的 ** Core Foundation 对象 ** 不在 ARC 的管理下，需要手工管理它们的引用计数。</li><li>避免循环引用问题。</li><li>block及delegate的内存管理。</li></ul><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>引用计数这种管理内存的方式有一个比较大的瑕疵，即不能很好的解决循环引用（Reference Cycle）问题。</p><p>对象 A 和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。这两个对象的销毁依赖于对方的销毁，即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。</p><p><img src="https://s2.ax1x.com/2019/07/07/ZB8w6J.jpg" alt="ZB8w6J.jpg"></p><p>多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，这种情况更难被发现。</p><p><img src="https://s2.ax1x.com/2019/07/07/ZB80X9.png" alt="ZB80X9.png"></p><h4 id="主动断开"><a href="#主动断开" class="headerlink" title="主动断开"></a>主动断开</h4><p>如果程序员明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。例如如下一个引用链：</p><ol><li>Controller 持有了网络请求对象</li><li>网络请求对象持有了回调的 block</li><li>回调的 block 里面使用了 self（即持有了 Controller）</li></ol><p>解决办法就是，在网络请求结束，网络请求对象执行完 block 之后，主动释放对于 block 的持有，以便打破循环引用。（xxx.Block = nil）</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。</p><p>在 iOS 开发中，弱引用通常在 delegate 模式中使用，View Controller 的 delegate 成员变量通常是一个弱引用，以避免两个 ViewController 造成循环引用问题，例如tableView的delegate。</p><p><img src="https://s2.ax1x.com/2019/07/07/ZB8dl4.png" alt="ZB8dl4.png"></p><h5 id="弱引用的实现原理"><a href="#弱引用的实现原理" class="headerlink" title="弱引用的实现原理"></a>弱引用的实现原理</h5><p>系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。</p><p>从原理我们得知，弱引用的使用是有<strong>额外开销</strong>的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用，因为：</p><ul><li>当我们在创建这个对象时，如果临时使用一个弱引用持有它，就会因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。</li><li>大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。</li></ul><h2 id="Xcode-检测循环引用"><a href="#Xcode-检测循环引用" class="headerlink" title="Xcode 检测循环引用"></a>Xcode 检测循环引用</h2><p>在 Xcode 的菜单栏选择：Product -&gt; Profile，然后选择 “Leaks”，再点击右下角的”Profile” 按钮开始检测。</p><p>我们在模拟器里进行一些界面的切换。如果出现了内存泄漏，就可以在 Instruments 中看到红色的带”x”的图标写着“n new leaks”..</p><p>点击 “Leaks Checks” 栏，再点击”Cycles &amp; Roots”，就可以看到以图形方式显示出来的循环引用。可以比较方便地找到循环引用的对象了。如图：</p><p><img src="https://s2.ax1x.com/2019/07/07/ZB8NfU.png" alt="ZB8NfU.png"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> ARC </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“git add .” not worked - “诡异”问题解决</title>
      <link href="/%E2%80%9Cgit-add-%E2%80%9D-not-worked-%E2%80%9C%E8%AF%A1%E5%BC%82%E2%80%9D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html"/>
      <url>/%E2%80%9Cgit-add-%E2%80%9D-not-worked-%E2%80%9C%E8%AF%A1%E5%BC%82%E2%80%9D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html</url>
      
        <content type="html"><![CDATA[<div class="note warning"><p>听终端的话，别留下warning。</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"fuckit"</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">  (commit or discard the untracked or modified content <span class="keyword">in</span> submodules)</span><br><span class="line"></span><br><span class="line">modified:   xxx/themes/next (modified content, untracked content)</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>自从把博客源码托管到github仓库之后，腰也不酸了，腿也不痛了，一口气上五楼..咳咳</p><p>之后我给hexo换了一个NEXT主题，爽炸了！可是今天修改了主题某个js文件，<br>“<strong>git status</strong>”之后却显示<em>“nothing to commit”</em> ???</p><p>上github上看源码仓库，却发现主题文件夹下空空如也..仓库却显示没问题，<strong>git log</strong>，一直停留在上个提交版本。</p><p>于是一直死循环操作“<strong>git add .</strong>”&amp;&amp;“<strong>git commit -m “xxx”</strong>”，<br>终端却一直无情回复我“Changes not staged for commit”，如上面那段代码所示。</p><p>尝试按照终端提示的办法无法解决。</p><p>这就很诡异了？于是我花了一个晚上疯狂踩坑..</p><h2 id="爬坑"><a href="#爬坑" class="headerlink" title="爬坑"></a>爬坑</h2><p>搜索了各个关键词句，看了stackoverflow和几篇无用博文还是没有找到合适的解决。<br>直觉是文件引入的问题，一口气把next文件 “<strong>git rm –f xxx/themes/next</strong>” 再add进去，仔细一看却发现有如下提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">warning: adding embedded git repository: xxx/themes/next</span><br><span class="line">hint: You<span class="string">'ve added another git repository inside your current repository.</span></span><br><span class="line"><span class="string">hint: Clones of the outer repository will not contain the contents of</span></span><br><span class="line"><span class="string">hint: the embedded repository and will not know how to obtain it.</span></span><br><span class="line"><span class="string">hint: If you meant to add a submodule, use:</span></span><br><span class="line"><span class="string">hint:</span></span><br><span class="line"><span class="string">hint: git submodule add &lt;url&gt; xxx/themes/next</span></span><br><span class="line"><span class="string">hint:</span></span><br><span class="line"><span class="string">hint: If you added this path by mistake, you can remove it from the</span></span><br><span class="line"><span class="string">hint: index with:</span></span><br><span class="line"><span class="string">hint:</span></span><br><span class="line"><span class="string">hint: git rm --cached xxx/themes/next</span></span><br><span class="line"><span class="string">hint:</span></span><br><span class="line"><span class="string">hint: See "git help submodule" for more information.</span></span><br></pre></td></tr></table></figure><p>还好我认识一点英文，想起当时是从git仓库直接克隆next的，却因为粗心没有看warning，径直commit了（居然也没事- -!），才会引发以上的惨剧。<br>于是乎赶紧把主题下的git仓库删除了。</p><p>偷了个懒，把next文件夹移走，commit，再移进来，add之后总算能看到一排排的主题相关文件辣～</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>git仓库下要提交A文件夹，A/B文件夹下也包含一个git仓库（.git）。使用<strong>git add .</strong> 就只能加入一个空的B文件夹。</p><hr><h4 id="这个故事告诉我们以LINUX“没有回应就是最好的回应”的尿性来说，还是好好看终端回复吧。"><a href="#这个故事告诉我们以LINUX“没有回应就是最好的回应”的尿性来说，还是好好看终端回复吧。" class="headerlink" title="这个故事告诉我们以LINUX“没有回应就是最好的回应”的尿性来说，还是好好看终端回复吧。"></a>这个故事告诉我们以LINUX“没有回应就是最好的回应”的尿性来说，还是好好看终端回复吧。</h4>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
