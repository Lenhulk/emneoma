<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解@synthesize和@dynamic]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-synthesize%E5%92%8C-dynamic.html</url>
    <content type="text"><![CDATA[@synthesize和@dynamic这对小伙伴也需要好好剖析呢！ 核心规则 @property有两个对应的词，一个是@synthesize，一个是@dynamic。 如果@synthesize和@dynamic都没写，那么默认的就是@syntheszie var = _var;。 synthesize @synthesize的语义是合成，如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。 在Xcode4.0之后编译器会默认为你的属性加上@synthesize，因此我们可以认为，synthesize是property属性的一部分，它是系统为property生成变量的重要步骤。 简而言之，它的作用就是自动合成 _ivar+getter+setter。 一个过时的完整setter&amp;getter写法 12345678910111213141516171819@interface Sample()@property(nonatomic, strong, readwrite)NSObject *sampleObject;@end@implementation Sample@synthesize sampleObject = _sampleObject;//getter- (NSObject *)sampleObject&#123; return _sampleObject;&#125;//setter- (void)setSampleObject:(NSObject *)sampleObject&#123; _sampleObject = sampleObject;&#125;@end 上述代码就是以前的写法，可以更直观的理解到synthesize默认合成的成员变量会自动在ivar前加上下划线，在重写getter&amp;setter的时候，需要操作的是该带下划线的成员变量，property只是定义了该成员变量的属性名，原子操作和内存管理等特性。 dynamic @dynamic与@synthesize相反，它告诉编译器,属性的setter与getter方法由用户自己实现，不自动生成。（当然对于readonly的属性只需提供getter即可）。 假如一个属性被声明为@dynamic var，然后你没有提供@setter方法和@getter方法，编译的时候没问题，但是当程序运行到instance.var =someVar，或者当运行到 someVar = var时，对应参数的getter和setter方法就会在其他地方去寻找，比如父类。最后当找不到对应方法，由于缺getter/setter方法同样会导致崩溃。 用到@dynamic的地方很少： 用于声明我要手动实现setter/getter方法，提高代码可读性。 子类中的重载参数可以设为@dynamic，实现和父类共用一个参数； 动态生成类和变量的情景（如动态model生成）。 重点补充@synthesize 合成实例变量的规则 如果指定了成员变量的名称，会生成一个指定的名称的成员变量 @synthesize foo = _foo;。如果这个成员已经存在了就不再生成了； 如果手动写成@synthesize foo; 会生成一个名称为 foo 的成员变量，也就是说：如果没有指定成员变量的名称会自动生成一个属性同名的成员变量； 假如 property 名为 foo，同时还存在一个名为 _foo 的实例变量，则不会自动合成新变量。并且Xcode会报警告。 synthesize什么情况下会用？正常情况下，你不需要使用的synthesize，因为大多数情况下，系统都会为你自动合成。 但是，你必须能清楚，系统自动合成有时候也是会失效的。这时候就需要你手动添加 synthesize。 这些情况大约有3种： 手动修改生成的成员变量名字（不建议）。 手动实现了 setter/getter 俩方法。 如果你的属性是只读属性，但是你重写了getter方法，系统不会为你自动生成成员变量。你需要添加@synthesize。 如果你的属性可读可写，但是你同时重写了setter/getter方法，系统不会为你自动生成成员变量。你需要添加@synthesize。这种情况下，你如果只重写了setter/getter其中一个，系统仍然会执行自动合成。 实现了带有 property 属性的 protocol。 什么情况下不会 autosynthesis（自动合成）？ 属性同时重写了 setter 和 getter 时； 重写了只读属性的 getter 时； 使用了 @dynamic 时 在 @protocol 中定义的所有属性 重载的属性]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>sythesize</tag>
        <tag>dynamic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“URL Scheme” in iOS 浅析]]></title>
    <url>%2F%E2%80%9CURL-Scheme%E2%80%9D-in-iOS-%E6%B5%85%E6%9E%90.html</url>
    <content type="text"><![CDATA[做一个反复横跳的魔法师🧙‍♀️ 什么是URL Scheme在苹果的生态中，存在沙盒机制来保障用户的隐私和app间的信息安全。但是应用之间不可能毫无数据交流和业务跳转，因此URL Scheme就是打破这层隔膜的工具。通过URL Scheme，app可以跳转或者唤起另一个app，拉起分享，支付等业务功能，当然你也可以给自己的app定制一个专属URL Scheme让别的app和你进行互动。 URL Scheme 浅析URL：统一资源定位符；URL地址格式排列为：scheme://host:port/path 。 类似的，一个 URL Schemes 分为 Scheme、Action、Parameter、Value 这 4 个部分，中间用冒号 :、斜线 /、问号 ?、等号 = 相连接。 Scheme这个东西在 URL 里本来用来表示协议，比如 http、https、ftp 等。但是，在 iOS 的这些 URL 里它们就不是协议了，而是启动一个应用的 URL。 链接头和斜线之后，跟的是动作（Action）。动作在一些文档里也被称为「Command（命令）」。 在动作之后可以接参数（Parameter）也可以不接，「参数以问号 ? 为起始」，所以不接参数就不用带这个问号。 （这一套机制也因为灵活高效方便而受众于各iOS组件化开发解决方案） 通用的规则： 冒号:：在链接头和命令之间； 双斜杠 //：在链接头和命令之间，有时会是三斜杠 ///； 问号 ?：在命令和参数之间； 等号 =：在参数和值之间； 「和」符号 &amp;：在一组参数和另一组参数之间。 Tips： 我们可以直接用safari 访问：URL Scheme://，就可以唤醒对应的 APP，可以用此来测试是否给自己的app配制正确。 URL Scheme 跳转使用以跳转支付宝进行支付为例： 在infor.plist文件中添加 LSApplicationQueriesSchemes 数组，直接点击“+”号，在value一栏填上支付宝的Scheme——“alipay”； LSApplicationQueriesSchemes：是在iOS 9 以后苹果新增的一个参数，这个类别增加之后，可以使用UIApplication的canOpenURL:方法来判断是否安装了这个 URL scheme 对应的 APP。否则会报错提示：-canOpenURL: failed for URL: &quot;xxx://&quot; - error: &quot;This app is not allowed to query for scheme xxx&quot;；如果直接调用跳转代码跳转到不存在的app 也会崩溃。 *UIApplication - canOpenURL: *判断我们的目标app是否有安装在本机 *UIApplication - openURL: *来拉起对应的app iOS 10中，该方法被openURL:options:completionHandler:方法替代。 定义自己URL Scheme 让其它app跳转URL Scheme必须能唯一标识一个APP，如果你设置的URL Scheme与别的APP的URL Scheme冲突时，你的APP不一定会被启动起来。因为当你的APP在安装的时候，系统里面已经注册了你的URL Scheme。 一般情况下，是会调用先安装的app。但是iOS的系统app的URL Scheme肯定是最高的。所以我们定义URL Scheme的时候，尽量避开系统app已经定义过的URL Scheme。 操作步骤： 在info.plist文件中添加 CFBundleURLTypes 数组，给每一个item的CFBundleURLSchemes填值，同时可以给他们一个标示在CFBundleURLName里。 如果直接操作info.plist文件不明白，可以按这样的步骤添加： 点击工程名-&gt;target-&gt;Info-&gt;URL Types-&gt;点击“+”号*， 然后按需填写URL Scheme等参数，再回头看info文件就有值了。 当你完成了这些，其它app就可以根据你的scheme拉起你的app。 拉起app后的操作在AppDelegate中实现系统方法 application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey,id&gt; *)options 就可以解析传递过来的URL Scheme ，定制你要拉起的页面 发送的请求 传递的请求参数 及回调。 iOS10以上系统常用URL Scheme设置页面 App-Prefs:root (之前在那个设置页面，就跳转到相应的设置页面) 无线局域网 App-Prefs:root=WIFI 蓝牙 App-Prefs:root=Bluetooth 蜂窝移动网络 App-Prefs:root=MOBILE_DATA_SETTINGS_ID 个人热点 App-Prefs:root=INTERNET_TETHERING 运营商 App-Prefs:root=Carrier 通知 App-Prefs:root=NOTIFICATIONS_ID 通用 App-Prefs:root=General 通用-关于本机 App-Prefs:root=General&amp;path=About 通用-键盘 App-Prefs:root=General&amp;path=Keyboard 通用-辅助功能 App-Prefs:root=General&amp;path=ACCESSIBILITY 通用-语言与地区 App-Prefs:root=General&amp;path=INTERNATIONAL 通用-还原 App-Prefs:root=Reset 墙纸 App-Prefs:root=Wallpaper Siri App-Prefs:root=SIRI 隐私 App-Prefs:root=Privacy Safari App-Prefs:root=SAFARI 音乐 App-Prefs:root=MUSIC 音乐-均衡器 App-Prefs:root=MUSIC&amp;path=com.apple.Music:EQ 照片与相机 App-Prefs:root=Photos FaceTime App-Prefs:root=FACETIME]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>URL Scheme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-镂空效果遮罩]]></title>
    <url>%2FiOS-%E9%95%82%E7%A9%BA%E6%95%88%E6%9E%9C%E9%81%AE%E7%BD%A9.html</url>
    <content type="text"><![CDATA[做新手指引/扫描二维码等的需要的镂空效果。 效果图(额，毛玻璃是我后期加的为了保护隐私实际是没有这一层的) 核心代码12345678910111213141516171819202122232425262728293031323334override func draw(_ rect: CGRect) &#123; super.draw(rect) clearBgView.layer.sublayers?.removeAll() // 全路径 let bgPath = UIBezierPath(rect: self.bounds) // 镂空路径 let hollowPath = UIBezierPath(roundedRect: hollowRects[idx], cornerRadius: 4) bgPath.append(hollowPath) /* // 虚线部分（需求，可以不写） let line = CAShapeLayer() line.fillColor = UIColor.clear.cgColor line.strokeColor = UIColor.white.cgColor line.lineWidth = 1 line.lineDashPattern = [3, 3] line.path = hollowPath.cgPath clearBgView.layer.addSublayer(line) */ // 遮罩 let mask = CAShapeLayer() mask.path = bgPath.cgPath mask.fillRule = kCAFillRuleEvenOdd //mask.fillColor = UIColor.black.cgColor //mask.opacity = 0.7 clearBgView.layer.addSublayer(mask) DispatchQueue.main.async &#123; //... 在这里添加或修改 image/label &#125; &#125; 每次点击，就调用self.setNeedsDisplay()，唤起drawRect方法重绘视图 hollowPath ：镂空路径。每次点击就根据传入的hollowRects数组修改镂空path的rect，并且重新将hollowPath append 到 bgPath，设置了EvenOdd属性之后，则重叠部分路径才会渲染（奇偶原则，偶数路径内视为外部，不填充） clearBgView：自定义在视图控制器视图上的背景。如果clearBgView是半透明黑色，那么直接给他设置mask遮罩就行了；如果 clearBgView是透明的，那么遮罩就必须加上fillColor填充色和opacity半透明属性。 maskView：实现半透明的遮罩。maskView要设置 **`usesEvenOddFillRule`** 为true 补充遮罩层的fillRule属性，even-odd rule与non-zero rule到底代表什么意思？ 奇偶规则(even-odd rule) 指从路径包围的区域任意点向外做一条射线，如果射线相交的边数总和为奇数，则认为该点在路径内部，填充相应区域。 如果交叉点的数量为偶数，则认为该点在路径之外，并且该区域未被填充。 非零规则(non-zero rule) 对于，从左到右路径的交叉点算作+1，从右到左路径的交叉点算作-1。 如果交叉的总和不为零，则认为该点在路径内，并且相应的区域被填充。 如果总和为0，则该点在路径之外，并且该区域未被填充。 Tips: 如果镂空部分是圆形或者椭圆形，则可以直接使clockwise属性为false，不用修改usesEvenOddFillRule属性，默认就是非零规则！也可达到镂空效果噢。 这篇文章对于这两个属性的分析就很详细： https://segmentfault.com/a/1190000022769490]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开发之术</tag>
        <tag>镂空</tag>
        <tag>BezierPath</tag>
        <tag>CAShapeLayer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-swift单例&可销毁单例]]></title>
    <url>%2FiOS-swift%E5%8D%95%E4%BE%8B-%E5%8F%AF%E9%94%80%E6%AF%81%E5%8D%95%E4%BE%8B.html</url>
    <content type="text"><![CDATA[这可能是你学过的第一种设计模式 单例相关 单例模式（Singleton Patten）是最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。 一般情况下,使用”shared” “sharedInstance” “default” “standard”等字样的,就是单例. 基本要求 只能有一个实例 必须内部自己创建自己的唯一实例 必须对所有其它对象提供该唯一实例 iOS 中的单例 UIApplication.shard ：每一个应用程序启动后创建的第一个单例对象就是UIApplication对象，利用UIApplication对象能进行一些应用级别的操作 NotificationCenter.defualt：通知中心，管理应用中的通知 FileManager.defualt：获取沙盒主目录的路径 URLSession.shared：管理网络连接 UserDefaults.standard：存储轻量级的本地数据 SKPaymentQueue.default()：管理应用内购的队列。系统会用 StoreKit framework 创建一个支付队列，每次使用时通过类方法 default() 去获取这个队列。 单例的优缺点优点： 提供了对唯一实例的受控访问：单例类封装了它的唯一实例，防止其它对象对自己的实例化，确保所有的对象都访问一个实例。 节约系统资源：由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。 伸缩性：单例模式的类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。 避免对资源的多重占用：比如写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作 缺点： 状态混乱：由于单例是共享的，可能有多个对象都会访问及改变单例的状态，所以当使用单例时，程序员无法清楚的知道单例当前的状态。 测试困难：测试困难主要是由于单例状态的混乱而造成的。因为单例的状态可以被其他共享的实例所修改，所以进行需要依赖单例的测试时，很难从一个干净、清晰的状态开始每一个 test case 访问混乱：由于单例是全局对象，所以无法对访问权限作出限定。程序任何位置、任何实例都可以对单例进行访问，容易引起访问混乱。 Objective-C单例 在.h文件中开放单例类方法的接口： 1+ (instanceType)sharedInstance; 在.m文件中声明一个静态对象，善用GCD实现单例： 12345678static MySingleton *sharedInstance = nil;+ (instanceType)sharedInstance &#123; static dispatch_once_t once; disptach_once(&amp;once, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance;&#125; Swift单例实现方式第一种方式：最简洁的方式，将实例定义为全局变量。 如果将上述实例变量在全局命名区（global namespace）第一次调用，由于Swift中全局变量是懒加载（lazy initialize）。 所以，在application(_:didFinishLaunchingWithOptions:)中调用的时候之后，shardManager会在AppDelegate类中被初始化，之后程序中所有调用sharedManager实例的地方将都使用该实例。 另外，Swift 全局变量初始化时默认使用dispatch_once，这保证了全局变量的构造器（initializer）只会被调用一次，保证了shardManager的原子性。 12345678910// 在全局命名区创建实例let sharedSingleton = MySingleton(string: someString)class MySingleton &#123; // 属性 let string: String // 初始化方法 init(string: String) &#123; self.string = string &#125;&#125; 1234567// 外部直接使用sharedInstancefunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; // 初始化位置，以及使用方式 print(sharedSingleton) ... return true&#125; 第二种方式：（使用最多的方式）使用static、private关键字，限定变量的作用域。 “static”关键字使shard成为全局变量，“private”关键字保证了单例的原子性。 12345678910class MySingleton &#123; // 全局变量 static let shared = MySingleton(string: someString) // 属性 let string: String // 初始化方法 private init(string: String) &#123; self.string = string &#125;&#125; 12// 使用MySingleton.shared 采用第二种方式实现单例，代码的可读性增加了，能够直观的分辨出这是一个单例。 第三种方式：第三种方式是第二种方式的变种，更加复杂。 让单例在闭包（Closure）中初始化，同时加入类方法来获取单例。 123456789101112131415161718class MySingleton &#123; // 全局变量 private static let sharedInstance: MySingleton = &#123; let shared = MySingleton(string: someString) // ...其它配置 return shared &#125;() // 属性 let string: String // 初始化 private init(string: String) &#123; self.string = string &#125; // 对外接口 class func shared() -&gt; MySingleton &#123; return sharedInstance &#125;&#125; 可以看出第三种方式虽然更加复杂，但是可以在闭包中作一些额外的配置。同时，调用单例的方式也不一样，需要调用单例中的类方法shared() 12// 使用MySingleton.shared() 可销毁单例虽说单例是全局唯一，但是遇到需要限定单例的作用域在某个库，某个框架里，当pop回到主工程，离开私有框架作用域时想要让单例销毁，下次进入再初始化。可以这样做： 12345678910111213141516171819202122class MySingleton &#123; // 全局变量 private static var _sharedInstance: MySingleton? // 属性 let string: String // 初始化 private init(string: String) &#123; self.string = string &#125; // 使用 class func shared() -&gt; MySingleton &#123; guard let instance = _sharedInstance else &#123; _sharedInstance = MySingleton(string: someString) return _sharedInstance &#125; return instance &#125; // 销毁 class func destroy() &#123; _sharedInstance = nil &#125;&#125; 123//使用方式MySingleton.shared()MySingleton.destroy()]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>swift</tag>
        <tag>Singleton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-动态加载字体（给Cocoapod库添加自定义字体文件）]]></title>
    <url>%2FiOS-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E4%BD%93%EF%BC%88%E7%BB%99Cocoapod%E5%BA%93%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E6%96%87%E4%BB%B6%EF%BC%89.html</url>
    <content type="text"><![CDATA[单想给该库增添一个自定义的字体又不想到主工程去做修改，保持主工程干净并且让子库可有自己独有的字体，该怎么做？ 注意事项 字体文件名不代表字体的名字，在向info.plist 文件中添加字体的时候添加的是字体文件的名字。 但是使用的时候我们需要字体真正的名字，查找方法可以：右键点击文件 -&gt; show in finder -&gt; 文件标题显示的就是字体的真名； 或者通过遍历打印所有系统安装的字体文件查找： 123456789101112&gt; //获得字体族的名字&gt; NSArray *arr = [UIFont familyNames];&gt; for (NSString *family in arr) &#123;&gt; //打印字体族名&gt; NSLog(@&quot;FamilyName:%@&quot;, family);&gt; NSArray *arr2 = [UIFont fontNamesForFamilyName:family];&gt; for (NSString *name in arr2) &#123;&gt; //打印字体名&gt; NSLog(@&quot;FontName:%@&quot;, name);&gt; &#125;&gt; &#125;&gt; 常规添加字体步骤 获取到一个字体文件比如 “DS-DIGI-1.ttf” 在info.plist中的”Fonts provided by application”栏新增一个item，填入你要添加的字体文件的文件名”DS-DIGI-1.ttf” 查找到正确的字体名，在项目中调用UIFont.fontWithName使用 1UIFont(name: "DS-Digital", size: 22) 私有库添加字体当开发私有pod库时，单想给该库增添一个自定义的字体又想保持主工程干净独立，并且让其它项目引用子库也不用手动导入字体，子库也能有自己单独管理的字体，该怎么做？ CTFontManager动态添加 将字体文件放到pod库对应的resource（资源）文件夹下 查找库的bundleA，再到bundleA查找字体文件路径URL 运用CTFontManagerRegisterFontsForURL动态加载字体 写成一个UIFont分类，加载库前调用 1234567891011121314151617181920212223242526272829303132333435363738extension UIFont &#123; static func registerFont(bundle: Bundle, fontName: String, fontExtension: String) -&gt; Bool &#123; guard let bundleURL = bundle.url(forResource: "MYComponent", withExtension: "bundle") else &#123; fatalError("Couldn't find bundle MYComponent") &#125; let myBundle = Bundle(url: bundleURL) guard let fontURL = myBundle?.url(forResource: fontName, withExtension: fontExtension) else &#123; fatalError("Couldn't find font \(fontName)") &#125; if let version = Float(UIDevice.current.systemVersion), version &gt;= 7.0 &#123; var error: Unmanaged&lt;CFError&gt;? if !CTFontManagerRegisterFontsForURL(fontURL as CFURL, .process, &amp;error) &#123; debugPrint("Error registering font: maybe it was already registered. :%@", error.debugDescription) return false &#125; &#125; else &#123; guard let fontDataProvider = CGDataProvider(url: fontURL as CFURL) else &#123; fatalError("Couldn't load data from the font \(fontName)") &#125; guard let font = CGFont(fontDataProvider) else &#123; fatalError("Couldn't create font from data") &#125; var error: Unmanaged&lt;CFError&gt;? // 内存泄漏? if !CTFontManagerRegisterGraphicsFont(font, &amp;error) &#123; debugPrint("Error registering font: maybe it was already registered. :%@", error.debugDescription) return false &#125; &#125; return true &#125;&#125; 使用方法还是fontWithName就可以了。 podSpec动态添加网上还有用podSpec文件，编译脚本进行hook的方法，通过在resources文件中搜索到字体文件，然后在编译期写入到plist文件，方法写起来比较复杂，且对ruby不熟，笔者用这个方法失败了希望有大神赐教。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546Pod::Spec.new do |s| # ... s.resources = "Resources/*.otf" # ... s.post_install do |library_representation| require 'rexml/document' library = library_representation.library proj_path = library.user_project_path proj = Xcodeproj::Project.new(proj_path) target = proj.targets.first # good guess for simple projects info_plists = target.build_configurations.inject([]) do |memo, item| memo &lt;&lt; item.build_settings['INFOPLIST_FILE'] end.uniq info_plists = info_plists.map &#123; |plist| File.join(File.dirname(proj_path), plist) &#125; resources = library.file_accessors.collect(&amp;:resources).flatten fonts = resources.find_all &#123; |file| File.extname(file) == '.otf' || File.extname(file) == '.ttf' &#125; fonts = fonts.map &#123; |f| File.basename(f) &#125; info_plists.each do |plist| doc = REXML::Document.new(File.open(plist)) main_dict = doc.elements["plist"].elements["dict"] app_fonts = main_dict.get_elements("key[text()='UIAppFonts']").first if app_fonts.nil? elem = REXML::Element.new 'key' elem.text = 'UIAppFonts' main_dict.add_element(elem) font_array = REXML::Element.new 'array' main_dict.add_element(font_array) else font_array = app_fonts.next_element end fonts.each do |font| if font_array.get_elements("string[text()='#&#123;font&#125;']").empty? font_elem = REXML::Element.new 'string' font_elem.text = font font_array.add_element(font_elem) end end doc.write(File.open(plist, 'wb')) end end]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开发之术</tag>
        <tag>字体</tag>
        <tag>Cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods和恼人的New build system]]></title>
    <url>%2FCocoaPods%E5%92%8C%E6%81%BC%E4%BA%BA%E7%9A%84New-build-system.html</url>
    <content type="text"><![CDATA[New build system 把我坑惨了啊 TAT CocoaPods对New build system水土不服如果您使用CocoaPods与新的Xcode构建系统(New build system)一起为您的应用程序开发库，会有一个对新手极不友好的BUG —— 即Xcode在构建pods库时不会获取上次pod install之后修改的最新代码。 参见radar 41126633。 也就是说，开发过程中每次修改了库代码，你就要重新clean -&gt; build -&gt; run，否则跑的还是旧代码！ “如果你是第一次接触库开发，第一次接触组件化开发，而且你的Xcode刚好升级到了10以上有了新的编译系统，那么你总是会莫名其妙踩进这个怪坑！其次，每次clean之后重新编译，对于比较大的项目就要消耗一堆时间，而且每次等待也是打断了开发的思路，这是非常严重的问题啊！” 最简单的方式就是改回旧的build system： File » Workspace Settings » Use Legacy Build. Tips: 记得在每次pod install之后，都得去改，因为xcworkspace默认也会使用新编译系统！ 为什么水土不服？长话短说：看一下项目的Build Phases。 有个Embed Pods Frameworks，可将构建的框架复制到项目中。 此功能使用一种称为Input/Output files的功能，该功能仅在受影响的文件已更改时才运行脚本。 这似乎在新的构建系统中被打破了，看看 Xcode bug 所说的。 更好的解决办法 升级你的CocoaPods版本至&gt;=1.6； 1gem update cocoapods 然后，您可以将installation option（安装选项）添加到Podfile中，以禁用Input/Output files的使用： 1234567use_frameworks!install! 'cocoapods', :disable_input_output_paths =&gt; truetarget 'HelloPod_Example' do # ...end 现在，当您再次运行pod install时，构建阶段将不再使用输入/输出文件，Cocoapods脚本将始终运行，以保证您的库代码始终是最新的。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
        <tag>NewBuildSystem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决scrollView中恼人的手势冲突]]></title>
    <url>%2F%E8%A7%A3%E5%86%B3scrollView%E4%B8%AD%E6%81%BC%E4%BA%BA%E7%9A%84%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81.html</url>
    <content type="text"><![CDATA[开发一个界面较为复杂的app，我们势必会出现在scrollview或者tableview上加上按钮或者手势，But.. Cell中Button点击高亮反馈为何有阻滞？ 又是什么阻挡了我tableview的滑动（滑动失效）？ ScrollView手势处理原理一款优秀的产品势必要有优秀的点击反馈，但是为何你做的列表 快速点击了cell上的按钮没有高亮，点击时间延长了才有效果！？ UIScrollView原理，以时间为轴线： 从你的手指touch屏幕开始，scrollView开始一个timer，如果： 150ms内如果你的手指没有任何动作，消息就会传给subView。 150ms内手指有明显的滑动（一个swipe动作），scrollView就会滚动，消息不会传给subView。 150ms内手指没有滑动，scrollView将消息传给subView，但是之后手指开始滑动，scrollView传送touchesCancelled消息给subView，然后开始滚动。 UIScrollView有一个BOOL类型的tracking属性，用来返回用户是否已经触及内容并打算开始滚动,当手指触摸到UIScrollView内容的一瞬间，会产生下面的动作： 拦截触摸事件 tracking属性变为YES 一个内置的计时器开始生效，用来监控在极短的事件间隔内是否发生了手指移动 当检测到时间间隔内手指发生了移动，UIScrollView自己触发滚动，tracking属性变为NO，手指触摸下即使有(可以响应触摸事件的)内部控件也不会再响应触摸事件。 当检测到时间间隔内手指没有移动，tracking属性保持YES，手指触摸下如果有(可以响应触摸事件的)内部控件，则将触摸事件传递给控件进行处理。 当你手指放在按钮上，维持150ms，才会触发UIButton的触摸事件！ delaysContentTouches不过上面的工作原理其实有一个属性开关来控制：delaysContentTouches（默认true） 只要将scrollview的这个属性设置为false，滚动视图将会第一时间处理响应者链的手势传递！ （按钮一点即亮～） 这时就会立刻执行touchesShouldBegin: withEvent: inContentView:方法！ （这个方法是最先接收到滑动事件的，优先于button的 UIControlEventTouchDown，以及- (void)touchesCancelled:(NSSet*)touches withEvent:(UIEvent*)event） 如果设置为true，touch事件沿着消息响应链传递; 如果设置为false，表示UIScrollView接收这个滚动事件，不必沿着消息响应链传递了。 touchesShouldCancelled:withEvent:当我们正在触摸屏幕的时候，如果出现了低电量、有电话呼入等等这样的系统事件时候，低电量或者电话的窗口会置为前台，这个时候touchesCancelled方法就会被调用。这大多数是由iOS系统发出的一些事件，导致触摸事件的中断，一般情况下直接调用touchesEnd即可。 如果返回true ，(系统默认)是允许UIScrollView，按照消息响应链向子视图传递消息的 如果返回false，UIScrollView,就接收不到滑动事件了。 canCancelContentTouches这个Bool类型的值控制contentview里的触摸是否总能引发跟踪(tracking)。（默认true） 如果设置为false，这消息一旦传递给subView，这scroll事件不会再发生。 如果属性值为true并且跟踪到手指正触摸到一个内容控件，这时如果用户拖动手指的距离足够产生滚动，那么内容控件将收到一个touchesCancelled:withEvent:消息，而scrollview将这次触摸作为滚动来处理。 如果值为false，一旦contentview开始跟踪(tracking==YES)，则无论手指是否移动，scrollView都不会滚动。 将按钮点击反馈出来为了使我的cell或者子控件上的按钮有点击效果，将 delaysContentTouches设置为false，我的按钮重获了第一时间的反馈效果。 当delaysContentTouches设置为false之后，scrollview的滑动有时会失效， 我的手指经过了button（有点击高亮效果）再移开，scrollview不会接收滑动事件，UIButton阻挡掉了我的滑动手势！ 如果同时再主动修改canCancelContentTouches这个属性改为true，滑动手势仍然会被阻挡😂（这个属性基本没有用到过，但是先记一下）。 修复滑动手势效果：当将手指按下时，cell上的按钮会更改颜色，这会提供视觉反馈，以确认您抬起手指时将激活哪个按钮。接着用户如果将手指从按钮上拖动，则划出该按钮时，触摸这个事件将被取消，并且该按钮取消高亮显示，将用户手势变为滑动滚动scrollview。 这时我们的技巧是，重写上文中提到的，touchesShouldCancel(in:) ，自己决定是否允许滚动视图取消控件中的触摸！ 这里实现了一个scrollView, tableView, collectionView的父控件，他们可以防止UIButton或者某些不应该吃掉手势的控件作出不当的行为（但是最好还是保留UITextInput, UISlider, 以及UISwitch阻挡手势的权利）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import UIKit// These let you start a touch on a control that's inside a scroll view,// and then if you start dragging, it cancels the touch on the button// and lets you scroll instead. Without these scroll view subclasses,// controls in scroll views will eat touches that start in them, which// prevents scrolling and makes the app feel broken.//// The UITextInput exception is for cases where you have a text field// or a text view in a scroll view. If you press and hold there, you want// to get the text editing magnifier cursor, instead of canceling the// touch in the text input element.//// Ditto for UISlider and UISwitch: if the table view eats the drag gesture,// they feel broken. Feel free to add your own exceptions if you have custom// controls that require swiping or dragging to function.final class ControlContainableScrollView: UIScrollView &#123; override func touchesShouldCancel(in view: UIView) -&gt; Bool &#123; if view is UIControl &amp;&amp; !(view is UITextInput) &amp;&amp; !(view is UISlider) &amp;&amp; !(view is UISwitch) &#123; return true &#125; return super.touchesShouldCancel(in: view) &#125;&#125;final class ControlContainableTableView: UITableView &#123; override func touchesShouldCancel(in view: UIView) -&gt; Bool &#123; if view is UIControl &amp;&amp; !(view is UITextInput) &amp;&amp; !(view is UISlider) &amp;&amp; !(view is UISwitch) &#123; return true &#125; return super.touchesShouldCancel(in: view) &#125;&#125;final class ControlContainableCollectionView: UICollectionView &#123; override func touchesShouldCancel(in view: UIView) -&gt; Bool &#123; if view is UIControl &amp;&amp; !(view is UITextInput) &amp;&amp; !(view is UISlider) &amp;&amp; !(view is UISwitch) &#123; return true &#125; return super.touchesShouldCancel(in: view) &#125;&#125; 只要使用了这个两个技巧，你能保留scrollview上交互控件的良好点击反馈，又能像原生tableview一样自然的滑动取消点击cell的高亮并且变成滚动scrollview，带来更自然更好的用户体验哇！！！ UIGestureRecognizerDelegate解决scrollView嵌套问题—— 当你需要在scrollView上加上滑动手势的时候，或者遇到scrollView嵌套scrollView的时候。 *gestureRecognizer(_:shouldRecognizeSimultaneouslyWith:)* 这个方法可以让手势继续向下一个响应者传递，手势加在ScrollView或者tableView上也不会有冲突，不需要通过offset差值去计算滑动方向，效果相当完美。 比方有这样一个普通需求： 上滑的时候，先不让子scrollView滑动（更改contentOffsetY为0），而是隐藏topView头部内容控件，再让子scrollView开始滑动 下滑的时候，等子scrollView滑到最上方之后（contentOffsetY为0），再允许父ScrollView滑动，滚动到topView头部控件顶部 我们可以这样实现： 创建UIScrollView的子类，实现代理UIGestureRecognizerDelegate的gestureRecognizer(_:shouldRecognizeSimultaneouslyWith:)方法；返回true，让滑动事件可以向父View传递： 12345678class MyScrollView: UIScrollView, UIGestureRecognizerDelegate &#123; var isSimultaneousGesture: bool = true func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -&gt; Bool &#123; return self.isSimultaneousGesture &#125;&#125; 实现代理方法：（例子） 123456789101112131415161718192021222324252627282930313233343536extension CollisionViewController: UIScrollViewDelegate &#123; func scrollViewWillBeginDragging(_ scrollView: UIScrollView) &#123; if scrollView == self.myScrollView &#123; // 记录子scrollview的初始y轴位移 _lastOffsetY = self.myScrollView.contentOffset.y &#125; &#125; func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; if scrollView == self.myScrollView &#123; // anchor反正就是topView的底部距离，设为一个产生形变的锚点 let anchorY = &lt;topView&gt;.bottom if self.scrollView.contentOffset.y &gt; _lastOffsetY &#123; // scrollView下滑 if superContainerScrollView!.contentOffset.y &lt;= anchorY &#123; self.scrollView.contentOffset.y = 0 superContainerScrollView?.setContentOffset(CGPoint(0, anchorY) animated: true) //让手势透传属性变为false scrollView.isSimultaneousGesture = false //这里可以做隐藏navigationBar的操作.. &#125; &#125; else if self.scrollView.contentOffset.y &lt; _lastOffsetY &#123; // scrollView上滑 if self.scrollView.contentOffset.y &lt; 0 &#123; self.scrollView.contentOffset.y = 0 superContainerScrollView?.setContentOffset(CGPoint(0, 0) animated: true) //让手势透传属性变为true scrollView.isSimultaneousGesture = true //这里可以做显示navigationBar的操作.. &#125; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开发之术</tag>
        <tag>ScrollView</tag>
        <tag>TableView</tag>
        <tag>手势</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不止配置ssh实现Sourcetree密钥访问远程仓库]]></title>
    <url>%2F%E4%B8%8D%E6%AD%A2%E9%85%8D%E7%BD%AEssh%E5%AE%9E%E7%8E%B0Sourcetree%E5%AF%86%E9%92%A5%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.html</url>
    <content type="text"><![CDATA[每次推拉合并代码到远程仓库都需要输入账号密码，那也太慢了太糗了吧？ 配置好了ssh私钥，但是为何报错port 22: Connection refused呢？ 终于免密操作了，咋电脑重启又不不好使了？ 背景团队实施了组件化开发，项目分成多个组件。 难以避免的会频繁使用pod及远程仓库操作，每天十来位同事在疯狂输出，一不留神项目git就几十个更新，如果每次pull/rebase/merge/push/代码都需要输入账号密码，那绝对1000%影响开发进度。 配置ssh “SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 几乎每一个远程仓库服务商（github, gitlab, bitbucket…）都有如何生成以及将密钥配置到远程仓库的教程，这里简单看看步骤 常规操作 生成新的ssh key 1ssh-keygen -t rsa -b 4096 -C "your_email@example.com" 或查看已存在的key 1ls -al ~/.ssh 将您的SSH私钥添加到ssh-agent（该agent为您实现身份验证操作哦）并将密码短语存储在Mac钥匙串中 1ssh-add -K ~/.ssh/id_rsa 将ssh密钥复制到剪贴板后，粘到远程仓库的配置中 1pbcopy &lt; ~/.ssh/id_rsa.pub -K选项是Apple的标准版本ssh-add，当您将ssh密钥添加到ssh-agent时，它将密码短语存储在您的钥匙串中 报错：ssh: connect to host gitlab.com port 22: Connection refused你已经将私钥添加到了代理和钥匙串，远程也配置好了，然鹅不管终端还是sourcetree操作还是会报错。 测试链接，如下是假如你想配置多个平台.. 此时你输入哪一个都会报错 123ssh -T git@github.comssh -T bitbucket.orgssh -T 192.160.2.xxx //工作的私有远程仓库 为什么呢？ 如果您使用的是macOS Sierra 10.12.2或更高版本，需要~/.ssh/config文件以将密钥自动加载到ssh-agent中，并将密码短语存储在密钥链中 也就是说ssh-add还不够，我还需要配置ssh的config文件，config文件涉及到很多不同字段有不同的作用，可以在：SSH的config配置之多账号简单管理，学习一哈！ 最后，根据我的需求，创建&amp;编辑了一个config文件，不同网站对应了不同的key： 123456789101112131415161718192021# GithubHost opensource Hostname ssh.github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github User xxxxx@xx.com # BitbucketHost private HostName bitbucket.org Preferredauthentications publickey IdentityFile ~/.ssh/id_ed25519_bb User git# Private GitLab instanceHost work HostName 192.160.2.xxx port 1888 Preferredauthentications publickey IdentityFile ~/.ssh/id_rsa_work User git 报错：Bad owner or permissions on ~/xxx/.ssh/config配置完config文件，再次通过ssh -T测试连接，却又报错，这次是配置文件的权限不够，我们给他权限 1sudo chmod 600 ~/xxx/.ssh/config 再次连接就成功了，会提示你successfully autheticated或者Hi ,welcome to XXX。 通过ssh这个通行证，您可以用sourcetree任意玩耍不再需要输入账号密码，也不再需要输入密钥的安全码了！😄 重启了Mac，sourcetree操作又报权限错误soucetree为啥会报错呢，因为他操作命令是不会帮你输入密码的，也就是rsa密钥的安全码！ 当用你用terminal操作git你就会发现，又需要输入rsa的passphase了。 在重启之后，ssh-agent估计（可能？）也是重启了，于是密钥丢失了。 意味着每次重启Mac你就要去执行ssh-add -K！ 我们把这几个命令自动化吧，在每次启动时执行shell，步骤： 找到自动操作.app，创建一个Automator 应用程序 选择“运行shell脚本”，输入命令，点击顶部未命名保存 系统偏好设置-&gt;用户与群组-&gt;登录项，选择我们保存的app文件，实现开机自启动]]></content>
      <tags>
        <tag>ssh</tag>
        <tag>shell</tag>
        <tag>Sourcetree</tag>
        <tag>Automator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS检测企业包(.ipa)掉签脚本]]></title>
    <url>%2FiOS%E6%A3%80%E6%B5%8B%E4%BC%81%E4%B8%9A%E5%8C%85(.ipa)%E6%8E%89%E7%AD%BE%E8%84%9A%E6%9C%AC.html</url>
    <content type="text"><![CDATA[“客户装不上app啦！”“客户打开app闪退啦！”“ios检查一下是不是掉签啦！” 遇到企业证书被Revoke的情况，会导致已装好并且手动信任的企业包app打开闪退，或新用户装上app图标是灰色的。 太烦了，每次检查要重新下载安装一次确认，浪费时间，流量，又没有技术含量，不能每次都要因为这种问题浪费宝贵的时间，而且是否掉签我们作为开发要用事实&amp;数据说话！ 我们可以用Apple自带的codesign命令对app文件内的签名导出 再通过OpenSSL命令去检查证书的有效期 如果检查不到有效期或者显示了”Revoked”，自然表示签名不可用，也意味着证书挂了。参考了几篇文（找不到了），并弄了一个脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# USAGE: ./checkSign.sh &#123;ipa文件名：xxx.ipa&#125;# 看到⚠️证明该ipa证书签名有问题# 删除文件echo "🗑 删除codesign,pem,plist,和“Payload”文件夹及其子文件"if [ -d "Payload" ] ; thenrm -rf Payloadfirm -f codesign0rm -f codesign1rm -f codesign2rm -f *.pemrm -f *.plistrm -f iTunesArtwork# 参数检查canshu=$1ipaFile=$&#123;canshu##*/&#125;# 截取&amp;拼接.appappFile=$&#123;ipaFile%.*&#125;".app"islegal=$(echo $1 | grep ".ipa$")echo "👀 请检查参数"echo "ipa: $ipaFile"echo "app: $appFile"if [ -n "$islegal" ]; then if [ ! -f "$ipaFile" ]; then echo "❌ “$1”文件不存在，结束进程" exit 0 fielse echo "❌ 参数格式必须是文件全名:xxx.ipa，结束进程" exit 0fi# 解压unzip -q $ipaFile# 导出签名codesign -dvv --extract-certificates Payload/*.appif [ ! -f "codesign0" ] || [ ! -f "codesign1" ] || [ ! -f "codesign2" ]; then echo "⚠️ 导出codesign完整3个文件失败，该ipa文件证书过期或者被损坏" #TODO: 可在这里做替换ipa操作else openssl x509 c-inform DER -in codesign0 -out codesign0.pem openssl x509 -inform DER -in codesign1 -out codesign1.pem openssl x509 -inform DER -in codesign2 -out codesign2.pem cat codesign1.pem codesign2.pem &gt; cachain.pem openssl x509 -inform DER -in codesign0 -noout -nameopt -oneline -subject -serial -dates if openssl ocsp -issuer cachain.pem -cert codesign0.pem -url `openssl x509 -in codesign0.pem -noout -ocsp_uri` -CAfile cachain.pem -header 'host' 'ocsp.apple.com' | grep revoked ; then echo "⚠️ 证书被Revoke，请替换" #TODO: 可在这里做替换ipa操作 else echo "💯执行完毕，该ipa包证书可用" fifi 这个脚本可以丢给运维，让他做定时检查，他还可以做掉签报警和切换等..以后掉签问题问运维，不要再来问我啦～（别打扰我摸鱼）]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>shell</tag>
        <tag>企业签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS应用内检测网络连接是否开启代理(VPN)]]></title>
    <url>%2FiOS%E5%BA%94%E7%94%A8%E5%86%85%E6%A3%80%E6%B5%8B%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E4%BB%A3%E7%90%86-VPN.html</url>
    <content type="text"><![CDATA[我们需要检测用户的网络IP地址是否开启了代理（VPN），防止一些用户通过关闭GPS，让我们的IP定位错误，非法获取我们限制了地域的优惠，或者是传递虚假网络信息。 可以通过判断“tap tun ipsec ppp” 这些字段是否在“CFNetworkCopySystemProxySettings”里，来判断vpn是否开启。 完整方法在此： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253- (BOOL)isVPNOn&#123; BOOL flag = NO; NSString *version = [UIDevice currentDevice].systemVersion; // need two ways to judge this. if (version.doubleValue &gt;= 9.0) &#123; NSDictionary *dict = CFBridgingRelease(CFNetworkCopySystemProxySettings()); NSArray *keys = [dict[@"__SCOPED__"] allKeys]; for (NSString *key in keys) &#123; if ([key rangeOfString:@"tap"].location != NSNotFound || [key rangeOfString:@"tun"].location != NSNotFound || [key rangeOfString:@"ipsec"].location != NSNotFound || [key rangeOfString:@"ppp"].location != NSNotFound)&#123; flag = YES; break; &#125; &#125; &#125; else &#123; struct ifaddrs *interfaces = NULL; struct ifaddrs *temp_addr = NULL; int success = 0; // retrieve the current interfaces - returns 0 on success success = getifaddrs(&amp;interfaces); if (success == 0) &#123; // Loop through linked list of interfaces temp_addr = interfaces; while (temp_addr != NULL) &#123; NSString *string = [NSString stringWithFormat:@"%s" , temp_addr-&gt;ifa_name]; if ([string rangeOfString:@"tap"].location != NSNotFound || [string rangeOfString:@"tun"].location != NSNotFound || [string rangeOfString:@"ipsec"].location != NSNotFound || [string rangeOfString:@"ppp"].location != NSNotFound) &#123; flag = YES; break; &#125; temp_addr = temp_addr-&gt;ifa_next; &#125; &#125; // Free memory freeifaddrs(interfaces); &#125; return flag;&#125; 这个是判断系统的vpn状态，还有一种是调起vpnExtension或着说NEVPNManager的时候的vpn状态可以通过实例化NEVPNManager，然后通过manager.connection.status来获取当前的vpn状态。 该方法有一个缺陷，就是如果用户是连接了已经开启代理的Wi-Fi网络，那我们就无法检测到啦！如果有更好的方法欢迎留言告知～]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开发之术</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS WKWebView实现Post请求]]></title>
    <url>%2FiOS-WKWebView%E5%AE%9E%E7%8E%B0Post%E8%AF%B7%E6%B1%82.html</url>
    <content type="text"><![CDATA[（敲锣打鼓）ZF渠道的朋友又来搞事情了！ （听好了听好了）现在的需求是这样的！ 通过我们向服务器发起一个A请求，服务器返回一个URL以及所有需要的参数，我们再通过WebView发起Post请求的方式（其中有重定向跳转）拿到最后的HTML信息。 因为UIWebView有内存泄漏和严重的性能问题，本着喜新厌旧的本性，项目中的WebView已经全面转了WKWebView。 WKWebView fail to load post request第一次尝试，自定义了SURLRequest，将方法改为post，将参数转码，甚至还自定义了content-type，然鹅请求却失败。 12345NSMutableURLRequest * requestShare = [[NSMutableURLRequest alloc]initWithURL:[NSURL URLWithString:self.urlStr]] [request setHTTPMethod:@"POST"];[requset setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];[request setHTTPBody:[@"id=12&amp;name=Jhon&amp;token=skjasjlfjalsl" dataUsingEncoding:NSUTF8StringEncoding]]; //示例[self.wkwebview loadRequest:request]; 后来谷歌了..发现由于 WKWebView 在独立进程里执行网络请求。一旦注册 http(s) scheme 后，网络请求将从 Network Process 发送到 App Process，这样 NSURLProtocol 才能拦截网络请求。在 webkit2 的设计里使用 MessageQueue 进行进程之间的通信，Network Process 会将请求 encode 成一个 Message,然后通过 IPC 发送给 App Process。出于性能的原因，encode 的时候 HTTPBody 和 HTTPBodyStream 这两个字段被丢弃掉了！官方源码 苹果工程师对此也作出了回复， 回复文章中，苹果工程师还非常热心的告诉开发者，哈哈你的UIWebView能够发送Post请求也只是一个意外，我们根本就没想让你们这样玩！WebView只能通过GET请求建立，要不你们尝试用JavaScript发post请求耍耍呗。 JS大法好OC的不足就让JS来补足吧（怪押韵的？） 我们可以利用JS来动态的生成HTML里的form标签，然后用form表单来实现POST请求。而且WKWebView即使不加载任何html和request，也可以直接执行js方法（吊炸天了）。 我们将JS代码定义成一个即插即用的宏方法。 1234567891011121314151617#define POST_JS @"function my_post(path, params) &#123;\var method = \"POST\";\var form = document.createElement(\"form\");\form.setAttribute(\"method\", method);\form.setAttribute(\"action\", path);\for(var key in params)&#123;\ if (params.hasOwnProperty(key)) &#123;\ var hiddenFild = document.createElement(\"input\");\ hiddenFild.setAttribute(\"type\", \"hidden\");\ hiddenFild.setAttribute(\"name\", key);\ hiddenFild.setAttribute(\"value\", params[key]);\ &#125;\ form.appendChild(hiddenFild);\&#125;\document.body.appendChild(form);\form.submit();\&#125;" 发送请求！ 123456// url - 请求发送的地址// paramStr - 要传递的参数,格式需要转成合法的json字符串,如：@"&#123;\"token\":\"cac6af340960485aa334416c8a34ddbf\"&#125;";// js - 需要wkwebView执行的JS代码，post一份form表单NSString * js = [NSString stringWithFormat:@"%@my_post(\"%@\", %@)",POST_JS,url,dataStr];[self.wkwebview evaluateJavaScript:js completionHandler:nil]; 嗯嗯，这样就太爽了。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>WKWebView</tag>
        <tag>开发之术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C中基础锁及其性能探究]]></title>
    <url>%2FObjective-C%E4%B8%AD%E5%9F%BA%E7%A1%80%E9%94%81%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E6%8E%A2%E7%A9%B6.html</url>
    <content type="text"><![CDATA[懂点锁，才能写好多线程。 线程锁我们在多线程中大展拳脚的时候，总可能会遇到资源争夺，导致数据混乱，线程锁这个时候可以为我们的数据资源保驾护航，在OC中基础的锁有@synchronized，NSLock，pthread，OSSpinLock。 我们先构建一个类，假设当前它是我们的一个共享资源，且func1与func2是两个互斥的操作，如下： 1234567@implementation TokenObj- (void)func1&#123; //读写操作1&#125;- (void)func2&#123; //读写操作2&#125; 然后，我们来看看如何使用以上四种锁实现在不同线程切换的时候锁住资源。 @synchronized1234567891011121314TokenObj *obj = [[TokenObj alloc] init];//线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; @synchronized(obj)&#123; [obj func1]; &#125;&#125;);//线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1);//以保证让线程2的代码后执行 @synchronized(obj)&#123; [obj func2]; &#125;&#125;); @synchronized指令中的token为该锁的唯一标识对象，该指令只对相同标识中的对象进行加锁。用@synchronized实现锁的优点就是不需要在代码中显式地创建锁对象，便可以实现锁的机制，但是它会隐式地添加一个异常处理例程（该历处理例程会在异常抛出的时候自动释放互斥锁）来保护代码。因此该指令会因为该例程带来额外的内存开销，下面我们对比性能的时候就能看到。 NSLock123456789101112131415TokenObj *obj = [[TokenObj alloc] init];NSLock *lock = [[NSLock alloc] init];//线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [lock lock]; [obj func1]; [lock unlock];&#125;);//线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); [lock lock]; [obj func2]; [lock unlock];&#125;); NSLock是Cocoa提供给我们最基本的锁对象，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。 pthread1234567891011121314TokenObj *obj = [[TokenObj alloc] init];__block pthread_mutex_t mutex;pthread_mutex_init(&amp;mutex, NULL);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;mutex); [obj func1]; pthread_mutex_unlock(&amp;mutex);&#125;);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); pthread_mutex_lock(&amp;mutex); [obj func2]; pthread_mutex_unlock(&amp;mutex);&#125;); pthread_mutex_t是C语言模块，在使用时要引用”pthread.h”。 dispatch_semaphore 实现锁以上代码构建多线程我们就已经用到了GCD的dispatch_async方法，其实在GCD中也已经提供了一种信号机制，使用它我们也可以来构建一把”锁”(从本质意义上讲，信号量与锁是有区别，具体差异参加信号量与互斥锁之间的区别) 123456789101112131415TokenObj *obj = [TokenObj alloc] init];dispatch_semaphore semaphore = dispatch_semaphore_create(1);//线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [obj func1]; dispatch_semaphore_signal(semaphore);&#125;);//线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [obj func2]; dispatch_semaphore_signal(semaphore);&#125;); 可以去了解一下dispatch_semaphore。 OSSpinLock (deprecated)12345678910111213TokenObj *obj = [[TokenObj alloc] init];OSSpinLock spinlock = OS_SPINLOCK_INIT;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; OSSpinLockLock(&amp;spinlock); [obj func1]; OSSpinLockUnlock(&amp;spinlock);&#125;);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); OSSpinLockLock(&amp;spinlock); [obj func2]; OSSpinLockUnlock(&amp;spinlock);&#125;); OSSpinLock因为存在安全问题，在iOS10.0以后就被弃用了，可以使用os_unfair_lock_lock替代（除了 OSSpinLock 外，dispatch_semaphore 和 pthread_mutex 性能是最高的）。具体参考：不再安全的 OSSpinLock。 性能探究12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#import &lt;libkern/OSAtomic.h&gt;#import &lt;pthread.h&gt;#define ITERATIONS (1024*1024*32)static unsigned long long disp=0, land=0;int main()&#123; double then, now; unsigned int i, count; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; OSSpinLock spinlock = OS_SPINLOCK_INIT; NSAutoreleasePool *pool = [NSAutoreleasePool new]; NSLock *lock = [NSLock new]; then = CFAbsoluteTimeGetCurrent(); for(i=0;i&lt;ITERATIONS;++i) &#123; [lock lock]; [lock unlock]; &#125; now = CFAbsoluteTimeGetCurrent(); printf("NSLock: %f sec\n", now-then); then = CFAbsoluteTimeGetCurrent(); IMP lockLock = [lock methodForSelector:@selector(lock)]; IMP unlockLock = [lock methodForSelector:@selector(unlock)]; for(i=0;i&lt;ITERATIONS;++i) &#123; lockLock(lock,@selector(lock)); unlockLock(lock,@selector(unlock)); &#125; now = CFAbsoluteTimeGetCurrent(); printf("NSLock+IMP Cache: %f sec\n", now-then); then = CFAbsoluteTimeGetCurrent(); for(i=0;i&lt;ITERATIONS;++i) &#123; pthread_mutex_lock(&amp;mutex); pthread_mutex_unlock(&amp;mutex); &#125; now = CFAbsoluteTimeGetCurrent(); printf("pthread_mutex: %f sec\n", now-then); then = CFAbsoluteTimeGetCurrent(); for(i=0;i&lt;ITERATIONS;++i) &#123; OSSpinLockLock(&amp;spinlock); OSSpinLockUnlock(&amp;spinlock); &#125; now = CFAbsoluteTimeGetCurrent(); printf("OSSpinlock: %f sec\n", now-then); id obj = [NSObject new]; then = CFAbsoluteTimeGetCurrent(); for(i=0;i&lt;ITERATIONS;++i) &#123; @synchronized(obj) &#123; &#125; &#125; now = CFAbsoluteTimeGetCurrent(); printf("@synchronized: %f sec\n", now-then); [pool release]; return 0;&#125; 用以上代码分别对四种基础锁的性能进行探究。代码中我们简单地加锁解锁重复33554432次，然后计算前后消耗时间，排除了自动释放池的影响。运行几次并取平均值统计出下图： @synchronized必须设置一个异常处理程序，它实际上最终会在那里采取一些内部锁。为了获得可锁定的锁而支付几个加锁解锁的费用。除了少写几行代码，带来的额外开销是其它锁的消耗3倍以上。 OSSpinLock甚至没有进入内核 - 它只是不断重新加载锁，希望它被解锁。如果锁保持超过几纳秒，这是非常低效的。一方面它节省了昂贵的系统调用和几个上下文切换，但是因为iOS系统关于线程优先级的更新，破坏了SpinLock的机制，因此它也变得不再安全了。 NSLock是pthread的一个漂亮的包装器。因此使用它而不是pthread没有多大意义。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>基础知识</tag>
        <tag>线程锁</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[atomic一定是线程安全的吗？]]></title>
    <url>%2Fatomic%E4%B8%80%E5%AE%9A%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F.html</url>
    <content type="text"><![CDATA[不是 线程安全在多线程同时工作的情况下，系统会给每条线程分配一个独立的栈空间，但是他们会公用堆里面的数据。通过运用线程锁和原子性等方法避免多条线程同时访问同一块内存变量造成的数据错误或者冲突。 atomic一定安全么？nonatomic的内存管理语义是非原子性的，非原子性的操作本来就是线程不安全的，而atomic的操作是原子性的，但是并不意味着它是线程安全的，它会增加正确的几率，能够更好的避免线程的错误，但是它仍然是线程不安全的。 atomic所说的线程安全只是保证了getter和setter存取方法的线程安全，并不能保证整个对象是线程安全的。 eg:当线程A进行写操作，这时其他线程的读或者写操作会因为该操作而等待。当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获得了在B线程中的值，这就破坏了线程安全，如果有线程C在A线程读操作前release了该属性，那么还会导致程序崩溃。所以仅仅使用atomic并不会使得线程安全，我们还要为线程添加lock来确保线程的安全。 而且，atomic比nonatomic的存取速度相差约20倍，因此在日常开发中一般都是使用nonatomic。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>atomic</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[assign VS weak? __weak VS __block?]]></title>
    <url>%2Fassign-VS-weak-block-VS-weak.html</url>
    <content type="text"><![CDATA[小知识点。 assignassign 用于基础类型的赋值，不改变属性的引用计数。如：NSInteger, CGFloat, int float double assign其实也可以用来修饰对象，但是你可不要轻易尝试。因为被assign修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil。如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。 weakweak 用于对象类型，不改变属性的引用计数，当该对象被释放的时候，该弱引用的属性自动失效并且被赋值为nil，该属性可以避免循环引用问题。 __weak__weak是所有权修饰符，被修饰的变量在使用结束后会被释放 置nil，其也不会在block代码块中被retain。所有权修饰符包括: __strong, __weak, unsafe_unretained, __autorealease。 使用unsafe_unretained 和 __weak都可以避免循环引用的问题，但由于前者是在iOS4.0以前weak的替代品，不会被自动置nil，会造成野指针问题，所以我们果断抛弃吧 __block__block用于指明当前变量可以在block内部进行修改（ARC下会被retain）。 因为在block申明的同时会捕获该block所使用的全部自动变量的值，仅有使用权没有修改权利，使用了__block关键字修饰后的变量可以在block内部进行修改。 在block内，要避免循环引用要使用： 1__weak__typeof(self)weakSelf =self; 并且，在使用到self之后的对象或者属性防止在使用之前被析构引发不可预测的问题，所以要使用strong再把它持有一下。 1__strong__typeof(weakSelf)strongSelf = weakSelf; 易混淆点若 object 本身沒有去 retain 这个 block (即block不是某个对象的property)，則可以直接在 block 中使用 self。比如自定义的block块（一个匿名函数）在代码中执行；经常问到的animation动画是否需要使用weakblock的问题。 事实上大多數的 iOS 原生套件，以及 GCD 的 block 是不會造成 retain cycle 的，因为他们并沒有去 retain block。 特别要注意的是，讲一个变量直接定义为实例变量而非属性的时候，在block中使用时还是会retain到self导致循环引用，因为ivar也是self的一部分： 1234567@interface XXXViewController () &#123; NSString *str;&#125;self.completionHandler = ^&#123; // 直接引用就相当于 self-&gt;str NSLog(@"%@", str);&#125; 但是！ivar是无法用weakSelf去取值的，因此这里正确的做法还是要用到weakSelf和strongSelf的帮助： 12345__weak __typeof(self) weakSelf = self;self.completionHandler = ^&#123; __strong __typeof(weakSelf) strongSelf = weakSelf; NSLog(@"%@", strongSelf-&gt;str);&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>基础知识</tag>
        <tag>修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS内存管理原理浅谈]]></title>
    <url>%2FiOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88.html</url>
    <content type="text"><![CDATA[2011 年，苹果在 WWDC 大会上提出了自动的引用计数（ARC）。ARC 背后的原理是依赖编译器的静态分析能力，通过在编译时找出合理的位置，自动插入引用计数管理代码，从而彻底解放被内存管理禁锢的码农iOS开发者。 引用计数原理引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。 当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象是，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。 解决的问题在没有引用计数的情况下，一般内存管理的原则是 “谁申请谁释放”，但是当多个对象需要引用到某一个X对象/变量时，哪些对象需要长时间使用X对象，都会遇到谁来销毁X对象的问题。引用计数的出现，使得对象在被创建和使用时retain count +1，使用完后-1，对象的生命周期就可以交给引用计数来记录。 不要向已经释放的对象发送消息当某个对象的内存已经被回收，但是我们没有对他置空(nil)，仍然向它发送消息时，如果该内存被复用了，很可能会造成程序异常崩溃，也被称为僵尸对象或者野指针异常。 ARCARC 能解决 iOS 开发中 “极大部分” 的内存管理问题，但是开发者仍然需要注意： iOS 底层的 ** Core Foundation 对象 ** 不在 ARC 的管理下，需要手工管理它们的引用计数。 避免循环引用问题。 block及delegate的内存管理。 循环引用引用计数这种管理内存的方式有一个比较大的瑕疵，即不能很好的解决循环引用（Reference Cycle）问题。 对象 A 和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。这两个对象的销毁依赖于对方的销毁，即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。 多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，这种情况更难被发现。 主动断开如果程序员明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。例如如下一个引用链： Controller 持有了网络请求对象 网络请求对象持有了回调的 block 回调的 block 里面使用了 self（即持有了 Controller） 解决办法就是，在网络请求结束，网络请求对象执行完 block 之后，主动释放对于 block 的持有，以便打破循环引用。（xxx.Block = nil） 弱引用弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。 在 iOS 开发中，弱引用通常在 delegate 模式中使用，View Controller 的 delegate 成员变量通常是一个弱引用，以避免两个 ViewController 造成循环引用问题，例如tableView的delegate。 弱引用的实现原理系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。 从原理我们得知，弱引用的使用是有额外开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用，因为： 当我们在创建这个对象时，如果临时使用一个弱引用持有它，就会因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。 大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。 Xcode 检测循环引用在 Xcode 的菜单栏选择：Product -&gt; Profile，然后选择 “Leaks”，再点击右下角的”Profile” 按钮开始检测。 我们在模拟器里进行一些界面的切换。如果出现了内存泄漏，就可以在 Instruments 中看到红色的带”x”的图标写着“n new leaks”.. 点击 “Leaks Checks” 栏，再点击”Cycles &amp; Roots”，就可以看到以图形方式显示出来的循环引用。可以比较方便地找到循环引用的对象了。如图：]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>基础知识</tag>
        <tag>ARC</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“git add .” not worked - “诡异”问题解决]]></title>
    <url>%2F%E2%80%9Cgit-add-%E2%80%9D-not-worked-%E2%80%9C%E8%AF%A1%E5%BC%82%E2%80%9D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html</url>
    <content type="text"><![CDATA[听终端的话，别留下warning。 1234567891011$ git add .$ git commit -m "fuckit"On branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) (commit or discard the untracked or modified content in submodules) modified: xxx/themes/next (modified content, untracked content)no changes added to commit (use "git add" and/or "git commit -a") 起因自从把博客源码托管到github仓库之后，腰也不酸了，腿也不痛了，一口气上五楼..咳咳 之后我给hexo换了一个NEXT主题，爽炸了！可是今天修改了主题某个js文件，“git status”之后却显示“nothing to commit” ??? 上github上看源码仓库，却发现主题文件夹下空空如也..仓库却显示没问题，git log，一直停留在上个提交版本。 于是一直死循环操作“git add .”&amp;&amp;“git commit -m “xxx””，终端却一直无情回复我“Changes not staged for commit”，如上面那段代码所示。 尝试按照终端提示的办法无法解决。 这就很诡异了？于是我花了一个晚上疯狂踩坑.. 爬坑搜索了各个关键词句，看了stackoverflow和几篇无用博文还是没有找到合适的解决。直觉是文件引入的问题，一口气把next文件 “git rm –f xxx/themes/next” 再add进去，仔细一看却发现有如下提示： 123456789101112131415$ git add .warning: adding embedded git repository: xxx/themes/nexthint: You've added another git repository inside your current repository.hint: Clones of the outer repository will not contain the contents ofhint: the embedded repository and will not know how to obtain it.hint: If you meant to add a submodule, use:hint:hint: git submodule add &lt;url&gt; xxx/themes/nexthint:hint: If you added this path by mistake, you can remove it from thehint: index with:hint:hint: git rm --cached xxx/themes/nexthint:hint: See "git help submodule" for more information. 还好我认识一点英文，想起当时是从git仓库直接克隆next的，却因为粗心没有看warning，径直commit了（居然也没事- -!），才会引发以上的惨剧。于是乎赶紧把主题下的git仓库删除了。 偷了个懒，把next文件夹移走，commit，再移进来，add之后总算能看到一排排的主题相关文件辣～ 总结git仓库下要提交A文件夹，A/B文件夹下也包含一个git仓库（.git）。使用git add . 就只能加入一个空的B文件夹。 这个故事告诉我们以LINUX“没有回应就是最好的回应”的尿性来说，还是好好看终端回复吧。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>debug</tag>
      </tags>
  </entry>
</search>
