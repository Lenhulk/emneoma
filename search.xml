<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Objective-C中基础锁及其性能探究]]></title>
    <url>%2F2019%2F07%2F06%2FObjective-C%E4%B8%AD%E5%9F%BA%E7%A1%80%E9%94%81%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[懂点锁，才能写好多线程。 线程锁我们在多线程中大展拳脚的时候，总可能会遇到资源争夺，导致数据混乱，线程锁这个时候可以为我们的数据资源保驾护航，在OC中基础的锁有@synchronized，NSLock，pthread，OSSpinLock。 我们先构建一个类，假设当前它是我们的一个共享资源，且func1与func2是两个互斥的操作，如下： 1234567@implementation TokenObj- (void)func1&#123; //读写操作1&#125;- (void)func2&#123; //读写操作2&#125; 然后，我们来看看如何使用以上四种锁实现在不同线程切换的时候锁住资源。 @synchronized1234567891011121314TokenObj *obj = [[TokenObj alloc] init];//线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; @synchronized(obj)&#123; [obj func1]; &#125;&#125;);//线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1);//以保证让线程2的代码后执行 @synchronized(obj)&#123; [obj func2]; &#125;&#125;); @synchronized指令中的token为该锁的唯一标识对象，该指令只对相同标识中的对象进行加锁。用@synchronized实现锁的优点就是不需要在代码中显式地创建锁对象，便可以实现锁的机制，但是它会隐式地添加一个异常处理例程（该历处理例程会在异常抛出的时候自动释放互斥锁）来保护代码。因此该指令会因为该例程带来额外的内存开销，下面我们对比性能的时候就能看到。 NSLock123456789101112131415TokenObj *obj = [[TokenObj alloc] init];NSLock *lock = [[NSLock alloc] init];//线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [lock lock]; [obj func1]; [lock unlock];&#125;);//线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); [lock lock]; [obj func2]; [lock unlock];&#125;); NSLock是Cocoa提供给我们最基本的锁对象，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。 pthread1234567891011121314TokenObj *obj = [[TokenObj alloc] init];__block pthread_mutex_t mutex;pthread_mutex_init(&amp;mutex, NULL);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;mutex); [obj func1]; pthread_mutex_unlock(&amp;mutex);&#125;);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); pthread_mutex_lock(&amp;mutex); [obj func2]; pthread_mutex_unlock(&amp;mutex);&#125;); pthread_mutex_t是C语言模块，在使用时要引用”pthread.h”。 dispatch_semaphore 实现锁以上代码构建多线程我们就已经用到了GCD的dispatch_async方法，其实在GCD中也已经提供了一种信号机制，使用它我们也可以来构建一把”锁”(从本质意义上讲，信号量与锁是有区别，具体差异参加信号量与互斥锁之间的区别) 123456789101112131415TokenObj *obj = [TokenObj alloc] init];dispatch_semaphore semaphore = dispatch_semaphore_create(1);//线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [obj func1]; dispatch_semaphore_signal(semaphore);&#125;);//线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [obj func2]; dispatch_semaphore_signal(semaphore);&#125;); 可以去了解一下dispatch_semaphore。 OSSpinLock (deprecated)12345678910111213TokenObj *obj = [[TokenObj alloc] init];OSSpinLock spinlock = OS_SPINLOCK_INIT;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; OSSpinLockLock(&amp;spinlock); [obj func1]; OSSpinLockUnlock(&amp;spinlock);&#125;);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); OSSpinLockLock(&amp;spinlock); [obj func2]; OSSpinLockUnlock(&amp;spinlock);&#125;); OSSpinLock因为存在安全问题，在iOS10.0以后就被弃用了，可以使用os_unfair_lock_lock替代（除了 OSSpinLock 外，dispatch_semaphore 和 pthread_mutex 性能是最高的）。具体参考：不再安全的 OSSpinLock。 性能探究12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#import &lt;libkern/OSAtomic.h&gt;#import &lt;pthread.h&gt;#define ITERATIONS (1024*1024*32)static unsigned long long disp=0, land=0;int main()&#123; double then, now; unsigned int i, count; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; OSSpinLock spinlock = OS_SPINLOCK_INIT; NSAutoreleasePool *pool = [NSAutoreleasePool new]; NSLock *lock = [NSLock new]; then = CFAbsoluteTimeGetCurrent(); for(i=0;i&lt;ITERATIONS;++i) &#123; [lock lock]; [lock unlock]; &#125; now = CFAbsoluteTimeGetCurrent(); printf("NSLock: %f sec\n", now-then); then = CFAbsoluteTimeGetCurrent(); IMP lockLock = [lock methodForSelector:@selector(lock)]; IMP unlockLock = [lock methodForSelector:@selector(unlock)]; for(i=0;i&lt;ITERATIONS;++i) &#123; lockLock(lock,@selector(lock)); unlockLock(lock,@selector(unlock)); &#125; now = CFAbsoluteTimeGetCurrent(); printf("NSLock+IMP Cache: %f sec\n", now-then); then = CFAbsoluteTimeGetCurrent(); for(i=0;i&lt;ITERATIONS;++i) &#123; pthread_mutex_lock(&amp;mutex); pthread_mutex_unlock(&amp;mutex); &#125; now = CFAbsoluteTimeGetCurrent(); printf("pthread_mutex: %f sec\n", now-then); then = CFAbsoluteTimeGetCurrent(); for(i=0;i&lt;ITERATIONS;++i) &#123; OSSpinLockLock(&amp;spinlock); OSSpinLockUnlock(&amp;spinlock); &#125; now = CFAbsoluteTimeGetCurrent(); printf("OSSpinlock: %f sec\n", now-then); id obj = [NSObject new]; then = CFAbsoluteTimeGetCurrent(); for(i=0;i&lt;ITERATIONS;++i) &#123; @synchronized(obj) &#123; &#125; &#125; now = CFAbsoluteTimeGetCurrent(); printf("@synchronized: %f sec\n", now-then); [pool release]; return 0;&#125; 用以上代码分别对四种基础锁的性能进行探究。代码中我们简单地加锁解锁重复33554432次，然后计算前后消耗时间，排除了自动释放池的影响。运行几次并取平均值统计出下图： @synchronized必须设置一个异常处理程序，它实际上最终会在那里采取一些内部锁。为了获得可锁定的锁而支付几个加锁解锁的费用。除了少写几行代码，带来的额外开销是其它锁的消耗3倍以上。 OSSpinLock甚至没有进入内核 - 它只是不断重新加载锁，希望它被解锁。如果锁保持超过几纳秒，这是非常低效的。一方面它节省了昂贵的系统调用和几个上下文切换，但是因为iOS系统关于线程优先级的更新，破坏了SpinLock的机制，因此它也变得不再安全了。 NSLock是pthread的一个漂亮的包装器。因此使用它而不是pthread没有多大意义。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>线程锁</tag>
        <tag>多线程</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[atomic一定是线程安全的吗？]]></title>
    <url>%2F2019%2F06%2F23%2Fatomic%E4%B8%80%E5%AE%9A%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[不是 线程安全在多线程同时工作的情况下，系统会给每条线程分配一个独立的栈空间，但是他们会公用堆里面的数据。通过运用线程锁和原子性等方法避免多条线程同时访问同一块内存变量造成的数据错误或者冲突。 atomic一定安全么？nonatomic的内存管理语义是非原子性的，非原子性的操作本来就是线程不安全的，而atomic的操作是原子性的，但是并不意味着它是线程安全的，它会增加正确的几率，能够更好的避免线程的错误，但是它仍然是线程不安全的。 atomic所说的线程安全只是保证了getter和setter存取方法的线程安全，并不能保证整个对象是线程安全的。 eg:当线程A进行写操作，这时其他线程的读或者写操作会因为该操作而等待。当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获得了在B线程中的值，这就破坏了线程安全，如果有线程C在A线程读操作前release了该属性，那么还会导致程序崩溃。所以仅仅使用atomic并不会使得线程安全，我们还要为线程添加lock来确保线程的安全。 而且，atomic比nonatomic的存取速度相差约20倍，因此在日常开发中一般都是使用nonatomic。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>基础知识</tag>
        <tag>atomic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[assign VS weak? __weak VS __block?]]></title>
    <url>%2F2019%2F06%2F11%2Fassign-VS-weak-block-VS-weak%2F</url>
    <content type="text"><![CDATA[零碎却不简单。 assignassign 用于基础类型的赋值，不改变属性的引用计数。如：NSInteger, CGFloat, int float double assign其实也可以用来修饰对象，但是你可不要轻易尝试。因为被assign修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil。如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。 weakweak 用于对象类型，不改变属性的引用计数，当该对象被释放的时候，该弱引用的属性自动失效并且被赋值为nil，该属性可以避免循环引用问题。 __weak__weak是所有权修饰符，被修饰的变量在使用结束后会被释放。(不会在block代码块中被retain)所有权修饰符包括: __strong, __weak, __unsafe_unretained, __autorealease。 使用__unsafe_unretained 和 __weak都可以避免循环引用的问题，但由于前者是unsafe的，会造成野指针问题，所以尽量少用unsafe_unretained关键字 __block__block用于指明当前变量可以在block内部进行修改（ARC下会被retain）。 因为在block申明的同时会捕获该block所使用的全部自动变量的值，仅有使用权没有修改权利，使用了__block关键字修饰后的变量可以在block内部进行修改。 在block内，要避免循环引用要使用： 1__weak__typeof(self)weakSelf =self; 并且，在使用到self之后的对象或者属性防止在使用之前被析构引发不可预测的问题，所以要使用strong再把它持有一下。 1__strong__typeof(weakSelf)strongSelf = weakSelf; 易混淆点若 object 本身沒有去 retain 这个 block (即block不是某个对象的property)，則可以直接在 block 中使用 self。比如自定义的block块（一个匿名函数）在代码中执行；经常问到的animation动画是否需要使用weakblock的问题。 事实上大多數的 iOS 原生套件，以及 GCD 的 block 是不會造成 retain cycle 的，因为他们并沒有去 retain block。 特别要注意的是，讲一个变量直接定义为实例变量而非属性的时候，在block中使用时还是会retain到self导致循环引用，因为ivar也是self的一部分： 1234567@interface XXXViewController () &#123; NSString *str;&#125;self.completionHandler = ^&#123; // 直接引用就相当于 self-&gt;str NSLog(@"%@", str);&#125; 但是！ivar是无法用weakSelf去取值的，因此这里正确的做法还是要用到weakSelf和strongSelf的帮助： 12345__weak __typeof(self) weakSelf = self;self.completionHandler = ^&#123; __strong __typeof(weakSelf) strongSelf = weakSelf; NSLog(@"%@", strongSelf-&gt;str);&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>基础知识</tag>
        <tag>修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS内存管理原理浅谈]]></title>
    <url>%2F2019%2F05%2F30%2FiOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[iOS的内存管理策略是什么？ ARC又是为了什么而诞生的？ 来自面试官的拷问 2011 年，苹果在 WWDC 大会上提出了自动的引用计数（ARC）。ARC 背后的原理是依赖编译器的静态分析能力，通过在编译时找出合理的位置，自动插入引用计数管理代码，从而彻底解放被内存管理禁锢的码农iOS开发者。 引用计数原理引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。 当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象是，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。 解决的问题在没有引用计数的情况下，一般内存管理的原则是 “谁申请谁释放”，但是当多个对象需要引用到某一个X对象/变量时，哪些对象需要长时间使用X对象，都会遇到谁来销毁X对象的问题。引用计数的出现，使得对象在被创建和使用时retain count +1，使用完后-1，对象的生命周期就可以交给引用计数来记录。 不要向已经释放的对象发送消息当某个对象的内存已经被回收，但是我们没有对他置空(nil)，仍然向它发送消息时，如果该内存被复用了，很可能会造成程序异常崩溃，也被称为僵尸对象或者野指针异常。 ARCARC 能解决 iOS 开发中 “极大部分” 的内存管理问题，但是开发者仍然需要注意： iOS 底层的 ** Core Foundation 对象 ** 不在 ARC 的管理下，需要手工管理它们的引用计数。 避免循环引用问题。 block及delegate的内存管理。 循环引用引用计数这种管理内存的方式有一个比较大的瑕疵，即不能很好的解决循环引用（Reference Cycle）问题。 对象 A 和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。这两个对象的销毁依赖于对方的销毁，即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。 多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，这种情况更难被发现。 主动断开如果程序员明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。例如如下一个引用链： Controller 持有了网络请求对象 网络请求对象持有了回调的 block 回调的 block 里面使用了 self（即持有了 Controller） 解决办法就是，在网络请求结束，网络请求对象执行完 block 之后，主动释放对于 block 的持有，以便打破循环引用。（xxx.Block = nil） 弱引用弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。 在 iOS 开发中，弱引用通常在 delegate 模式中使用，View Controller 的 delegate 成员变量通常是一个弱引用，以避免两个 ViewController 造成循环引用问题，例如tableView的delegate。 弱引用的实现原理系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。 从原理我们得知，弱引用的使用是有额外开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用，因为： 当我们在创建这个对象时，如果临时使用一个弱引用持有它，就会因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。 大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。 Xcode 检测循环引用在 Xcode 的菜单栏选择：Product -&gt; Profile，然后选择 “Leaks”，再点击右下角的”Profile” 按钮开始检测。 我们在模拟器里进行一些界面的切换。如果出现了内存泄漏，就可以在 Instruments 中看到红色的带”x”的图标写着“n new leaks”.. 点击 “Leaks Checks” 栏，再点击”Cycles &amp; Roots”，就可以看到以图形方式显示出来的循环引用。可以比较方便地找到循环引用的对象了。如图：]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>基础知识</tag>
        <tag>ARC</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“git add .” not worked - “诡异”问题解决]]></title>
    <url>%2F2019%2F05%2F26%2F%E2%80%9Cgit-add-%E2%80%9D-not-worked-%E2%80%9C%E8%AF%A1%E5%BC%82%E2%80%9D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[听终端的话，别留下warning。 1234567891011$ git add .$ git commit -m "fuckit"On branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) (commit or discard the untracked or modified content in submodules) modified: xxx/themes/next (modified content, untracked content)no changes added to commit (use "git add" and/or "git commit -a") 起因自从把博客源码托管到github仓库之后，腰也不酸了，腿也不痛了，一口气上五楼..咳咳 之后我给hexo换了一个NEXT主题，爽炸了！可是今天修改了主题某个js文件，“git status”之后却显示“nothing to commit” ??? 上github上看源码仓库，却发现主题文件夹下空空如也..仓库却显示没问题，git log，一直停留在上个提交版本。 于是一直死循环操作“git add .”&amp;&amp;“git commit -m “xxx””，终端却一直无情回复我“Changes not staged for commit”，如上面那段代码所示。 尝试按照终端提示的办法无法解决。 这就很诡异了？于是我花了一个晚上疯狂踩坑.. 爬坑搜索了各个关键词句，看了stackoverflow和几篇无用博文还是没有找到合适的解决。直觉是文件引入的问题，一口气把next文件 “git rm –f xxx/themes/next” 再add进去，仔细一看却发现有如下提示： 123456789101112131415$ git add .warning: adding embedded git repository: xxx/themes/nexthint: You've added another git repository inside your current repository.hint: Clones of the outer repository will not contain the contents ofhint: the embedded repository and will not know how to obtain it.hint: If you meant to add a submodule, use:hint:hint: git submodule add &lt;url&gt; xxx/themes/nexthint:hint: If you added this path by mistake, you can remove it from thehint: index with:hint:hint: git rm --cached xxx/themes/nexthint:hint: See "git help submodule" for more information. 还好我认识一点英文，想起当时是从git仓库直接克隆next的，却因为粗心没有看warning，径直commit了（居然也没事- -!），才会引发以上的惨剧。于是乎赶紧把主题下的git仓库删除了。 偷了个懒，把next文件夹移走，commit，再移进来，add之后总算能看到一排排的主题相关文件辣～ 总结git仓库下要提交A文件夹，A/B文件夹下也包含一个git仓库（.git）。使用git add . 就只能加入一个空的B文件夹。 这个故事告诉我们以LINUX“没有回应就是最好的回应”的尿性来说，还是好好看终端回复吧。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>debug</tag>
      </tags>
  </entry>
</search>
