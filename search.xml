<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS内存管理原理浅谈]]></title>
    <url>%2F2019%2F05%2F30%2FiOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[iOS的内存管理策略是什么？ARC又是为了什么而诞生的？这都是好问题。 2011 年，苹果在 WWDC 大会上提出了自动的引用计数（ARC）。ARC 背后的原理是依赖编译器的静态分析能力，通过在编译时找出合理的位置，自动插入引用计数管理代码，从而彻底解放被内存管理禁锢的码农iOS开发者。 引用计数原理引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。 当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象是，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。 解决的问题在没有引用计数的情况下，一般内存管理的原则是 “谁申请谁释放”，但是当多个对象需要引用到某一个X对象/变量时，哪些对象需要长时间使用X对象，都会遇到谁来销毁X对象的问题。引用计数的出现，使得对象在被创建和使用时retain count +1，使用完后-1，对象的生命周期就可以交给引用计数来记录。 不要向已经释放的对象发送消息当某个对象的内存已经被回收，但是我们没有对他置空(nil)，仍然向它发送消息时，如果该内存被复用了，很可能会造成程序异常崩溃，也被称为僵尸对象或者野指针异常。 ARCARC 能解决 iOS 开发中 “极大部分” 的内存管理问题，但是开发者仍然需要注意： iOS 底层的 ** Core Foundation 对象 ** 不在 ARC 的管理下，需要手工管理它们的引用计数。 避免循环引用问题。 block及delegate的内存管理。 循环引用引用计数这种管理内存的方式有一个比较大的瑕疵，即不能很好的解决循环引用（Reference Cycle）问题。 对象 A 和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。这两个对象的销毁依赖于对方的销毁，即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。 多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，这种情况更难被发现。 主动断开如果程序员明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。例如如下一个引用链： Controller 持有了网络请求对象 网络请求对象持有了回调的 block 回调的 block 里面使用了 self（即持有了 Controller） 解决办法就是，在网络请求结束，网络请求对象执行完 block 之后，主动释放对于 block 的持有，以便打破循环引用。（xxx.Block = nil） 弱引用弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。 在 iOS 开发中，弱引用通常在 delegate 模式中使用，View Controller 的 delegate 成员变量通常是一个弱引用，以避免两个 ViewController 造成循环引用问题，例如tableView的delegate。 弱引用的实现原理系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。 从原理我们得知，弱引用的使用是有额外开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用，因为： 当我们在创建这个对象时，如果临时使用一个弱引用持有它，就会因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。 大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。 Xcode 检测循环引用在 Xcode 的菜单栏选择：Product -&gt; Profile，然后选择 “Leaks”，再点击右下角的”Profile” 按钮开始检测。 我们在模拟器里进行一些界面的切换。如果出现了内存泄漏，就可以在 Instruments 中看到红色的带”x”的图标写着“n new leaks”.. 点击 “Leaks Checks” 栏，再点击”Cycles &amp; Roots”，就可以看到以图形方式显示出来的循环引用。可以比较方便地找到循环引用的对象了。如图：]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“git add .” not worked - “诡异”问题解决]]></title>
    <url>%2F2019%2F05%2F26%2F%E2%80%9Cgit-add-%E2%80%9D-not-worked-%E2%80%9C%E8%AF%A1%E5%BC%82%E2%80%9D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[听终端的话，别留下warning。 1234567891011$ git add .$ git commit -m "fuckit"On branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) (commit or discard the untracked or modified content in submodules) modified: xxx/themes/next (modified content, untracked content)no changes added to commit (use "git add" and/or "git commit -a") 起因自从把博客源码托管到github仓库之后，腰也不酸了，腿也不痛了，一口气上五楼..咳咳 之后我给hexo换了一个NEXT主题，爽炸了！可是今天修改了主题某个js文件，“git status”之后却显示“nothing to commit” ??? 上github上看源码仓库，却发现主题文件夹下空空如也..仓库却显示没问题，git log，一直停留在上个提交版本。 于是一直死循环操作“git add .”&amp;&amp;“git commit -m “xxx””，终端却一直无情回复我“Changes not staged for commit”，如上面那段代码所示。 尝试按照终端提示的办法无法解决。 这就很诡异了？于是我花了一个晚上疯狂踩坑.. 爬坑搜索了各个关键词句，看了stackoverflow和几篇无用博文还是没有找到合适的解决。直觉是文件引入的问题，一口气把next文件 “git rm –f xxx/themes/next” 再add进去，仔细一看却发现有如下提示： 123456789101112131415$ git add .warning: adding embedded git repository: xxx/themes/nexthint: You've added another git repository inside your current repository.hint: Clones of the outer repository will not contain the contents ofhint: the embedded repository and will not know how to obtain it.hint: If you meant to add a submodule, use:hint:hint: git submodule add &lt;url&gt; xxx/themes/nexthint:hint: If you added this path by mistake, you can remove it from thehint: index with:hint:hint: git rm --cached xxx/themes/nexthint:hint: See "git help submodule" for more information. 还好我认识一点英文，想起当时是从git仓库直接克隆next的，却因为粗心没有看warning，径直commit了（居然也没事- -!），才会引发以上的惨剧。于是乎赶紧把主题下的git仓库删除了。 偷了个懒，把next文件夹移走，commit，再移进来，add之后总算能看到一排排的主题相关文件辣～ 总结git仓库下要提交A文件夹，A/B文件夹下也包含一个git仓库（.git）。使用git add . 就只能加入一个空的B文件夹。 这个故事告诉我们以LINUX“没有回应就是最好的回应”的尿性来说，还是好好看终端回复吧。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
