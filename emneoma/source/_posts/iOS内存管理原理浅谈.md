---
title: iOS内存管理原理浅谈
date: 2019-05-30 00:52:16
tags: iOS
categories: iOS
---

{% cq %}
iOS的内存管理策略是什么？ ARC又是为了什么而诞生的？

**来自面试官的拷问**
{% endcq %}

{% qnimg 201905/opl-big19.jpg %}

<!-- more -->


*2011 年，苹果在 WWDC 大会上提出了自动的引用计数（ARC）。
ARC 背后的原理是依赖编译器的静态分析能力，通过在编译时找出合理的位置，自动插入引用计数管理代码，从而彻底解放被内存管理禁锢的~~码农~~iOS开发者。*

## 引用计数 ##

### 原理 ###
引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。

当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象是，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。

{% qnimg 201905/memory-ref-count1.png %}

### 解决的问题 ###
在没有引用计数的情况下，一般内存管理的原则是 “谁申请谁释放”，但是当多个对象需要引用到某一个X对象/变量时，哪些对象需要长时间使用X对象，都会遇到谁来销毁X对象的问题。
引用计数的出现，使得对象在被创建和使用时_retain count_ +1，使用完后-1，对象的生命周期就可以交给引用计数来记录。

### 不要向已经释放的对象发送消息 ###
当某个对象的内存已经被回收，但是我们没有对他置空(nil)，仍然向它发送消息时，如果该内存被复用了，很可能会造成程序异常崩溃，也被称为僵尸对象或者野指针异常。

## ARC ##

ARC 能解决 iOS 开发中 “极大部分” 的内存管理问题，但是开发者仍然需要注意：

+ iOS 底层的 ** Core Foundation 对象 ** 不在 ARC 的管理下，需要手工管理它们的引用计数。
+ 避免循环引用问题。
+ block及delegate的内存管理。

### 循环引用 ###
引用计数这种管理内存的方式有一个比较大的瑕疵，即不能很好的解决循环引用（Reference Cycle）问题。

对象 A 和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。这两个对象的销毁依赖于对方的销毁，即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。

{% qnimg 201905/memory-cycle-2.png %}

多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，这种情况更难被发现。

{% qnimg 201905/memory-cycle-3.png %}

#### 主动断开 ####

如果程序员明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。例如如下一个引用链：

1. Controller 持有了网络请求对象
2. 网络请求对象持有了回调的 block
3. 回调的 block 里面使用了 self（即持有了 Controller）

解决办法就是，在网络请求结束，网络请求对象执行完 block 之后，主动释放对于 block 的持有，以便打破循环引用。（xxx.Block = nil）

#### 弱引用 ####

弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。

在 iOS 开发中，弱引用通常在 delegate 模式中使用，View Controller 的 delegate 成员变量通常是一个弱引用，以避免两个 ViewController 造成循环引用问题，例如tableView的delegate。

{% qnimg 201905/memory-cycle-4.png %}

##### 弱引用的实现原理 #####
系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。

从原理我们得知，弱引用的使用是有**额外开销**的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用，因为：

+ 当我们在创建这个对象时，如果临时使用一个弱引用持有它，就会因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。
+ 大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。

## Xcode 检测循环引用 ##

在 Xcode 的菜单栏选择：Product -> Profile，然后选择 “Leaks”，再点击右下角的”Profile” 按钮开始检测。

我们在模拟器里进行一些界面的切换。如果出现了内存泄漏，就可以在 Instruments 中看到红色的带"x"的图标写着“n new leaks”..

点击 “Leaks Checks” 栏，再点击”Cycles & Roots”，就可以看到以图形方式显示出来的循环引用。可以比较方便地找到循环引用的对象了。如图：

{% qnimg 201905/memory-instruments-5.png %}
